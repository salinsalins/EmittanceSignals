# coding: utf-8
'''
Created on Jul 2, 2017

@author: sanin
'''
# used to parse files more easily
from __future__ import with_statement

import os.path
import shelve
import sys

try:
    from PyQt4.QtGui import QMainWindow
    from PyQt4.QtGui import QApplication
    from PyQt4.QtGui import qApp
    from PyQt4.QtGui import QFileDialog
    from PyQt4.QtGui import QTableWidgetItem
    from PyQt4 import uic
except:
    from PyQt5.QtWidgets import QMainWindow
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QtWidgets import qApp
    from PyQt5.QtWidgets import QFileDialog
    from PyQt5.QtWidgets import QTableWidgetItem
    from PyQt5 import uic

import numpy as np
from findRegions import *
from my_isfread import my_isfread as isfread
from smooth import smooth
from readTekFiles import readTekFiles
import scipy.integrate
from scipy.integrate import simps
from scipy.interpolate import interp1d
from printl import printl 
from gaussfit import gaussfit 

_progName = 'Emittance'
_progVersion = '_2_2'
_settingsFile = _progName + '_init.dat'
_initScript =  _progName + '_init.py'
_logFile =  _progName + '_log.log'

class DesignerMainWindow(QMainWindow):
    """Customization for Qt Designer created window"""
    def __init__(self, parent = None):
        # initialization of the superclass
        super(DesignerMainWindow, self).__init__(parent)
        # setup the GUI --> function generated by pyuic4
        uic.loadUi('Emittance.ui', self)
        #self.setupUi(self)
        # connect the signals with the slots
        self.pushButton.clicked.connect(self.plotRaw)
        self.pushButton_3.clicked.connect(self.plotProcessed)
        self.actionOpen.triggered.connect(self.selectFolder)
        self.pushButton_2.clicked.connect(self.selectFolder)
        self.actionQuit.triggered.connect(qApp.quit)
        self.pushButton_4.clicked.connect(self.processFolder)
        self.pushButton_5.clicked.connect(self.plotXsub)
        self.pushButton_6.clicked.connect(self.calculateEmittance)
        self.pushButton_7.clicked.connect(self.erasePicture)
        self.comboBox_2.currentIndexChanged.connect(self.selectionChanged)
        #self.pushButton_8.clicked.connect(self.flipStopFlag)
        # variables definition
        self.stopFlag = False
        self.data = None
        self.paramsAuto = None
        self.fleNames = []
        self.folderName = ''
        printl(_progName + _progVersion + ' started')
        # restore global settings from default location
        self.restoreSettings()
        # add dataFolder to history
        i = self.comboBox_2.findText(self.folderName)
        if i >= 0:
            self.comboBox_2.setCurrentIndex(i)
        else:
            # add item to history  
            self.comboBox_2.insertItem(-1, self.folderName)
            self.comboBox_2.setCurrentIndex(0)
        # read data files
        self.parseFolder(folder = self.folderName)
        # restore local settings
        if not self.restoreSettings(folder = self.folderName):
            self.processFolder()
    
    def selectFolder(self):
        """Opens a dataFolder select dialog"""
        # open the dialog and get the selected dataFolder
        folder = self.folderName
        fileOpenDialog = QFileDialog(caption='Select directory with data files', directory=folder)
        # select folder, not file
        dataFolder = fileOpenDialog.getExistingDirectory()
        # if a dataFolder is selected
        if dataFolder:
            if self.folderName == dataFolder:
                return
            i = self.comboBox_2.findText(dataFolder)
            if i >= 0:
                self.comboBox_2.setCurrentIndex(i)
            else:
                # add item to history  
                self.comboBox_2.setCurrentIndex(-1)
                self.comboBox_2.insertItem(-1, dataFolder)
                self.comboBox_2.setCurrentIndex(0)
    
    def selectionChanged(self, i):
        #print("Current index %s. Selection changed %s"%(i,str(self.comboBox_2.currentText())))
        if i < 0:
            return
        dataFolder = str(self.comboBox_2.currentText())
        if self.folderName != dataFolder:
            #self.folderName = self.comboBox_2.currentText()
            #print('New folder selected %s'%dataFolder)
            # parse selected folder
            self.parseFolder(dataFolder)
            # restore local settings
            if not self.restoreSettings(folder=dataFolder, local=True):
                self.processFolder()
 
    def onQuit(self) :
        # save settings to folder
        self.saveSettings(folder = self.folderName)
        # save global settings
        self.saveSettings()

    def clearPicture(self, force=False):
        if force or self.checkBox.isChecked():
            # clear the axes
            self.mplWidget.canvas.ax.clear()
        
    def erasePicture(self):
        self.mplWidget.canvas.ax.clear()
        self.mplWidget.canvas.draw()

    def flipStopFlag(self):
        self.stopFlag = not self.stopFlag
        
    def removeInersections(self, y1, y2, index):
        # calculate relative first derivatives
        d1 = np.diff(y1)
        d1 = np.append(d1, d1[-1])
        d2 = np.diff(y2)
        d2 = np.append(d2, d2[-1])
        regout = []
        reg = findRegions(index)
        #print('Initial regions  %s'%str(reg))
        for r in reg:
            if y1[r[0]] > y2[r[0]] and y1[r[1]-1] < y2[r[1]-1]:
                if np.all(d1[r[0]:r[1]]*d2[r[0]:r[1]] < 0.0):
                    continue
            if y1[r[0]] < y2[r[0]] and y1[r[1]-1] > y2[r[1]-1]:
                if np.all(d1[r[0]:r[1]]*d2[r[0]:r[1]] < 0.0):
                    continue
            regout.append(r)
        #print('Filtered regions %s'%str(regout))
        return regout

    def parseFolder(self, folder, mask='*.isf'):
        printl('Parsing folder %s'%folder)
        # read data
        self.data, self.fileNames = readTekFiles(folder, mask)
        # number of files
        nx = len(self.fileNames)
        if nx <= 0 :
            return
        printl('%s%s Parsing folder %s'%(_progName, _progVersion, folder), 
               fileName = os.path.join(str(folder), _logFile))
        # fill list with file names
        self.listWidget.clear()
        # short file names list
        names = [name.replace(folder, '')[1:] for name in self.fileNames]
        for i in range(nx):
            names[i] = '%3d - %s'%(i,names[i])
        # fill listWidget
        self.listWidget.addItems(names)
        
        self.folderName = folder
    
    def processFolder(self):
        def plot(*args, **kwargs):
            axes = self.mplWidget.canvas.ax
            axes.plot(*args, **kwargs)
            zoplot()
            axes.grid(True)
            axes.legend(loc='best') 
            self.mplWidget.canvas.draw()

        def draw():
            self.mplWidget.canvas.draw()

        def zoplot(v=0.0, color='k'):
            axes = self.mplWidget.canvas.ax
            xlim = axes.get_xlim()
            axes.plot(xlim, [v, v], color=color)
            axes.set_xlim(xlim)

        def voplot(v=0.0, color='k'):
            axes = self.mplWidget.canvas.ax
            ylim = axes.get_ylim()
            axes.plot([v, v], ylim, color=color)
            axes.set_ylim(ylim)

        def cls():
            self.clearPicture()
            
        axes = self.mplWidget.canvas.ax
        folder = self.folderName
        printl('Processing folder %s'%folder)
        print('Reading data ...')
        # read data array
        data,files  = readTekFiles(folder)
        # number of files
        nx = len(files)
        if nx <= 0 :
            print('Nothing to process')
            return False
        print('%d files fond'%nx)

        # Y size of data
        ny = len(data[0])
        # define arrays
        zero  = np.zeros((nx, ny), dtype=np.float64)
        weight = np.zeros((nx, ny), dtype=np.float64)
        # index array
        ix = np.arange(ny)
        
        # smooth
        ns = 1
        try:
            ns = int(self.spinBox.value())
        except:
            pass
        
        # default parameters array
        params = [{'smooth':ns, 'offset':0.0, 'zero':np.zeros(ny), 'scale': 1.95} for i in range(nx)]
        
        # sooth data array
        print('Smoothing data ...')
        for i in range(nx) :
            y = data[i,:]
            smooth(y, params[i]['smooth'])
        
        # channel 0 is scan voltage by default
        x = data[0,:].copy()
        smooth(x, params[0]['smooth']*2)
        # find longest monotonic region of scan voltage
        xdiff = np.diff(x)
        xdiff = np.append(xdiff, xdiff[-1])
        mask = xdiff >= 0.0
        regions = findRegions(np.where(mask)[0])         
        # find longest region
        xr = [0,0]
        for r in regions:
            if r[1]-r[0] >= xr[1]-xr[0]:
                xr = r
        mask = xdiff <= 0.0
        regions = findRegions(np.where(mask)[0])         
        for r in regions:
            if r[1]-r[0] >= xr[1]-xr[0]:
                xr = r
        xi = np.arange(xr[0], xr[1])
        params[0]['range'] = xr
        print('Using %s region of scan voltage'%str(xr))
        # debug draw
        if int(self.comboBox.currentIndex()) == 8:
            cls()
            plot(ix, x, label='Scan voltage')
            plot(ix[xi], x[xi], '.')
                    
        # auto process data for zero line and offset
        print('Processing zero line ...')
        for i in range(1,nx-1) :
            print('Channel %d'%(i))
            y1 = data[i,:].copy()
            offset1 = params[i]['offset']
            y1 = y1 - offset1
            y2 = data[i+1,:].copy()
            offset2 = params[i+1]['offset']
            y2 = y2 - offset2
            # double smooth because zero line is slow 
            smooth(y1, params[i]['smooth']*2)
            smooth(y2, params[i+1]['smooth']*2)
            # offsets calculated from upper 10%
            y1min = np.min(y1)
            y1max = np.max(y1)
            dy1 = y1max - y1min
            y2min = np.min(y2)
            y2max = np.max(y2)
            dy2 = y2max - y2min
            dy = max([dy1, dy2])
            i1 = np.where(y1 > (y1max - 0.1*dy))[0]
            o1 = np.average(y1[i1])
            #print('Offset 1 %f'%o1)
            i2 = np.where(y2 > (y2max - 0.1*dy))[0]
            o2 = np.average(y2[i2])
            #print('Offset 2 %f'%o2)
            # debug draw 9
            if int(self.comboBox.currentIndex()) == 9 :
                indexes = self.listWidget.selectedIndexes()
                if (len(indexes) > 0) and (i == indexes[0].row()):
                    cls()
                    plot(y1,'r', label='r'+str(i))
                    zoplot(o1,'r')
                    plot(y2,'b', label='r'+str(i+1))
                    zoplot(o2,'b')
                    plot(i1, y1[i1], '.')
                    plot(i2, y2[i2], '.')
            # correct y2 and offset2 for calculated offsets
            y2 = y2 - o2 + o1
            offset2 = offset2 + o2 - o1 
            # zero line = where 2 signals are equal
            mask = np.abs(y1 - y2) < 0.05*dy1
            index = np.where(mask)[0]
            #print(findRegionsText(index))
            # filter signal intersections
            index = restoreFromRegions(findRegions(index, 50, 300, 100, 100, length=ny))
            if len(index) <= 0:
                index = np.where(mask)[0]
            # new offset
            offset = np.average(y2[index] - y1[index])
            #print('Offset for channel %d = %f'%((i+1), offset))
            # shift y2 and offset2
            y2 = y2 - offset
            offset2 = offset2 + offset 
            # index with new offset
            #print('4% index with corrected offset')
            mask = np.abs(y1 - y2) < 0.04*dy1
            index = np.where(mask)[0]
            #print(findRegionsText(index))
            # filter signal intersection
            regions = findRegions(index, 50)
            index = restoreFromRegions(regions, 0, 150, length=ny)
            #print(findRegionsText(index))
            # choose largest values
            mask[:] = False
            mask[index] = True
            mask3 = np.logical_and(mask, y1 >= y2)
            index3 = np.where(mask3)[0]
            # update zero for all channels
            for j in range(1,nx) :
                w = 1.0/((abs(i - j))**2 + 1.0)
                zero[j,index3] = (zero[j,index3]*weight[j,index3] + y1[index3]*w)/(weight[j,index3] + w)
                weight[j,index3] += w
            mask4 = np.logical_and(mask, y1 <= y2)
            index4 = np.where(mask4)[0]
            # update zero for all channels
            for j in range(1,nx) :
                w = 1.0/((abs(i + 1 - j))**2 + 1.0)
                zero[j,index4] = (zero[j,index4]*weight[j,index4] + y2[index4]*w)/(weight[j,index4] + w)
                weight[j,index4] += w
            # save processed parameters
            params[i+1]['offset'] = offset2
            # plot intermediate results
            if int(self.comboBox.currentIndex()) == 10 :
                indexes = self.listWidget.selectedIndexes()
                if len(indexes) > 0:
                    k = indexes[0].row()             
                    cls()
                    plot(ix, data[k,:], label='s'+str(k))
                    z = zero[k].copy() + params[k]['offset']
                    smooth(z, params[k]['smooth']*2)
                    plot(ix, z, label='z'+str(k))
            pass
        # save processed zero line
        for i in range(nx) :
            params[i]['zero'] = zero[i]
        # determine signal area
        print('Processing signals ...')
        for i in range(1, nx) :
            print('Channel %d'%i)
            y0 = data[i,:].copy()[xi]
            z = zero[i].copy()[xi] + params[i]['offset']
            smooth(z, params[i]['smooth']*2)
            y = y0 - z
            ymin = np.min(y)
            ymax = np.max(y)
            dy = ymax - ymin
            mask = y < (ymax - 0.5*dy)
            index = np.where(mask)[0]
            ra = findRegions(index)
            params[i]['range'] = xr
            # determine scale
            is1 = xi[0]
            is2 = xi[-1]
            if len(ra) >= 1:
                is1 = np.argmin(y[ra[0][0]:ra[0][1]]) + ra[0][0] + xi[0]
            if len(ra) >= 2:
                is2 = np.argmin(y[ra[1][0]:ra[1][1]]) + ra[1][0] + xi[0]
            params[i]['scale'] = 10.0/(x[is2] - x[is1])   # [mm/Volt]
            print('raw scale %f [mm/V]'%params[i]['scale'])
            if np.abs(x[is1]) < np.abs(x[is2]) :
                index = is1
            else:
                index = is2
            params[i]['minindex'] = index
            params[i]['minvoltage'] = x[index]
            print('minindex=%d u=%f [V]'%(index,x[index]))
            di = int(abs(is2 - is1)/2.0)
            ir1 = max([xi[ 0], index - di])
            ir2 = min([xi[-1], index + di])
            params[i]['range'] = [ir1, ir2]
            print('range %s'%str(params[i]['range']))
            # debug draw 11
            if int(self.comboBox.currentIndex()) == 11:
                indexes = self.listWidget.selectedIndexes()
                if (len(indexes) > 0) and (i == indexes[0].row()):
                    cls()
                    plot(xi, y, label='p'+str(i))
                    plot(ix[ir1:ir2], y[ir1 - xi[0]:ir2 - xi[0]], '.', label='range'+str(i))
                    voplot(is1, 'r')
                    voplot(is2, 'b')
                    draw()
        # filter scales
        sc = np.array([params[i]['scale'] for i in range(1,nx)])
        asc = np.average(sc)
        ssc = np.std(sc)
        index = np.where(abs(sc - asc) < 2.0*ssc)[0]
        asc1 = np.average(sc[index])
        index = np.where(abs(sc - asc) >= 2.0*ssc)[0]
        sc[index] = asc1
        for i in range(1,nx) :
            params[i]['scale'] = sc[i-1] 
            print('%d filtered scale %f [mm/V]'%(i,params[i]['scale']))

        # common parameters
        print('Set common parameters ...')
        # Parameters of Measurements
        #R  = 2.0e5        ; Ohm    Resistor for beamlet scanner FC
        #d1 = 0.4          ; mm    Analyzer hole diameter
        #d2 = 0.5          ; mm    Collector Slit Width
        #l1 = 213.0        ; mm    Distance From emission hole to analyzer hole
        #l2 = 200.0        ; mm    Distance From analyzer hole to slit collector
        params[0]['R'] = 2.0e5
        params[0]['d1'] = 0.4
        params[0]['d2'] = 0.5
        l1 = 213.0
        params[0]['l1'] = l1
        l2 = 200.0
        params[0]['l2'] = l2
        # set member variable
        self.paramsAuto = params

        # exec init script
        self.execInitScript()

        # X0 and ndh calculation
        x00 = np.zeros(nx-1)
        l1 = self.readParameter(0, "l1", 213.0, float)
        l2 = self.readParameter(0, "l2", 200.0, float)
        npt = 0
        sp = 0.0
        nmt = 0
        sm = 0.0
        for i in range(1, nx) :
            s = self.readParameter(i, "scale", 2.0, float)
            u = self.readParameter(i, "minvoltage", 0.0, float)
            j = self.readParameter(i, "minindex", 0, int)
            x00[i-1] = -s*u*l1/l2
            dx = 0.0
            if i > 1:
                dx = x00[i-1] - x00[i-2]
            if dx > 0.0:
                npt += 1
                sp += dx
            if dx < 0.0:
                nmt += 1
                sm += dx
            print('%3d N=%d u=%f s=%f X0=%f DX=%f'%(i, j, x[j], s, x00[i-1], dx))
        #print('npt=%d %f nmt=%d %f %f'%(npt,sp/npt,nmt,sm/nmt,sp/npt-l1/l2*10.))
        x01 = x00.copy()
        h = x00.copy()*0.0
        for i in range(1, nx-1) :
            dx = x00[i] - x00[i-1]
            if npt > nmt :
                x01[i] = x01[i-1] + sp/npt
                if dx > 0.0:
                    h[i] = h[i-1]
                else:
                    h[i] = h[i-1] + 10.0
            else:
                x01[i] = x01[i-1] + sm/nmt
                if dx < 0.0:
                    h[i] = h[i-1]
                else:
                    h[i] = h[i-1] - 10.0
        x01 = x01 - np.average(x01)
        k = int(np.argmin(np.abs(x01)))
        h = h - h[k]
        for i in range(1, nx) :
            params[i]['ndh'] = h[i-1]
            s = self.readParameter(i, "scale", 2.0, float)
            u = self.readParameter(i, "minvoltage", 0.0, float)
            x01[i-1] = (h[i-1] - s*u)*l1/l2 
            params[i]['x0'] = (h[i-1] - s*u)*l1/l2 
            print('%d X0 %f [mm] ndh=%f [mm]'%(i,params[i]['x0'],params[i]['ndh']))
            #params[i]['x0'] = x01[i-1] 
        # debug draw 12
        x0 = x01.copy()
        for i in range(1, nx) :
            x0[i-1] = self.readParameter(i, 'x0', 0.0, float)
        if int(self.comboBox.currentIndex()) == 12:
            cls()
            plot(x01-x01[k], 'o-', label='X0 calculated')
            plot(x0-x0[k], 'd-', label='X0 auto')
            draw()
        
        # save processed to member variable
        self.paramsAuto = params
        print('Auto parameters has been calculated')
        
        return True
                
    def readParameter(self, row, name, default=None, dtype=None, info=False, select=''):
        if name == 'zero':
            return self.readZero(row)
        vd = default
        t = 'default'
        v = vd
        try:
            va = self.paramsAuto[row][name]
            t = 'auto'
            v = va
        except:
            va = None
        try:
            vm = self.paramsManual[row][name]
            t = 'manual'
            v = vm
        except:
            vm = None
        if dtype is not None :
            v = dtype(v)
        if info :
            print('row:%d name:%s %s value:%s (default:%s auto:%s manual:%s)'%(row, name, t, str(v), str(vd), str(va), str(vm)))
        if select == 'manual':
            return vm
        if select == 'auto':
            return va
        if select == 'default':
            return vd
        return v

    def readZero(self, row):
        if self.data is None:
            return None
        try:
            z = self.paramsAuto[row]['zero'].copy()
        except:
            z = np.zeros_like(self.data[0])
        # manual zero line
        try:
            # manual regions
            zr = self.paramsManual[row]['zero']
            for zi in zr:
                try:
                    z0 = self.data[zi[0], :].copy()
                    ns0 = self.readParameter(zi[0], "smooth", 1, int)
                    of0 = self.readParameter(zi[0], "offset", 0.0, float)
                    smooth(z0, 2*ns0)
                    z[zi[1]:zi[2]] = z0[zi[1]:zi[2]] + of0
                except:
                    pass
        except:
            pass
        return z

    def readSignal(self, row):
        if self.data is None :
            return
        #print('Processing %d'%row)
        # scan voltage
        u = self.data[0, :].copy()
        # smooth
        ns = self.readParameter(0, "smooth", 100, int)
        smooth(u, ns)
        smooth(u, ns)
        # parameters
        # scanner base
        l2 = self.readParameter(0, "l2", 200.0, float)
        # load resistor
        R = self.readParameter(0, "R", 2.0e5, float)
        # signal
        y = self.data[row, :].copy()
        # smooth
        ns = self.readParameter(row, "smooth", 1, int)
        # offset
        of = self.readParameter(row, "offset", 0.0, float)
        # zero line
        z = self.readZero(row)
        # smooth
        smooth(y, ns)
        smooth(z, 2*ns)
        # subtract offset and zero
        y = y - z - of
        # convert signal to microAmperes
        y = y/R*1.0e6
        # signal region
        r0 = self.readParameter(0, "range", (0, len(y)))
        r = self.readParameter(row, "range", r0)
        index = np.arange(r[0],r[1])
        # scale
        s = self.readParameter(row, "scale", 1.0, float)
        # ndh
        ndh = self.readParameter(row, "ndh", 0.0, float)
        # x' in milliRadians
        xsub = (ndh - s*u) / l2 * 1000.0
        return (xsub, y, index)

    def plot(self, *args, **kwargs):
        axes = self.mplWidget.canvas.ax
        axes.plot(*args, **kwargs)
        #zoplot()
        #xlim = axes.get_xlim()
        #axes.plot(xlim, [0.0,0.0], color='k')
        #axes.set_xlim(xlim)
        axes.grid(True)
        axes.legend(loc='best') 
        self.mplWidget.canvas.draw()

    def draw(self):
        self.mplWidget.canvas.draw()

    def zoplot(self, v=0.0, color='k'):
        axes = self.mplWidget.canvas.ax
        xlim = axes.get_xlim()
        axes.plot(xlim, [v, v], color=color)
        axes.set_xlim(xlim)

    def voplot(self, v=0.0, color='k'):
        axes = self.mplWidget.canvas.ax
        ylim = axes.get_ylim()
        axes.plot([v, v], ylim, color=color)
        axes.set_ylim(ylim)

    def cls(self):
        self.clearPicture()

    def plotRaw(self):
        self.clearPicture()
        if self.data is None :
            return
        # draw chart
        ns = self.spinBox.value()
        axes = self.mplWidget.canvas.ax
        #table = self.tableWidget
        #indexes = table.selectedIndexes()
        indexes = self.listWidget.selectedIndexes()
        y = self.data[0, :]
        ix = self.spinBox_2.value()
        if ix >= 0:
            x = self.data[ix, :].copy()
            smooth(x, self.spinBox.value())
            xTitle = 'Scan Voltage, V'
        else:
            x = np.arange(len(y))
            xTitle = 'Point index'
        for i in indexes :
            row = i.row()
            y = self.data[row, :].copy()
            smooth(y, ns)
            z = self.readZero(row) + self.readParameter(row, 'offset')
            axes.plot(x, y, label='raw'+str(row))
            axes.plot(x, z, label='zero'+str(row))
        axes.plot(axes.get_xlim(), [0.0,0.0], color='k')
        axes.grid(True)
        axes.set_title('Signals from Tektronix oscilloscope')
        axes.set_xlabel(xTitle)
        axes.set_ylabel('Signal Voltage, V')
        axes.legend(loc='best') 
        self.mplWidget.canvas.draw()

    def plotProcessed(self):
        """Plots processed signals"""
        if self.data is None :
            return
        self.execInitScript()
        axes = self.mplWidget.canvas.ax
        # clear the Axes
        self.clearPicture()
        # draw chart
        #table = self.tableWidget
        #indexes = table.selectedIndexes()
        indexes = self.listWidget.selectedIndexes()
        y = self.data[0, :]
        ix = self.spinBox_2.value()
        if ix >= 0:
            x = self.data[ix, :].copy()
            ns = 1
            try:
                ns = self.readParameter(ix, "smooth", 1, int)
            except:
                pass
            try:
                ns = int(self.spinBox.value())
            except:
                pass
            smooth(x, ns)
            xTitle = 'Scan Voltage, V'
        else:
            x = np.arange(len(y))
            xTitle = 'Point index'
        for i in indexes :
            row = i.row()
            u,y,index = self.readSignal(row)
            # convert to volts
            y = y * self.readParameter(0, "R", 2.0e5, float) / 1.0e6
            # plot processed signal
            self.plot(x, y, label='p'+str(row))
            # highlight signal region
            self.plot(x[index], y[index], label='range'+str(row))
            print('Signal %d'%row)
            self.readParameter(row, "smooth", 1, int, True)
            self.readParameter(row, "offset", 0.0, float, True)
            self.readParameter(row, "scale", 0.0, float, True)
            self.readParameter(row, "zero", (), None, True)
            r = self.readParameter(row, "range", (0,-1), None, True)
            self.readParameter(row, "x0", 0.0, float, True)
            self.readParameter(row, "ndh", 0.0, float, True)
            mi = self.readParameter(row, "minindex", 0, int, True)
            mv = self.readParameter(row, "minvoltage", 0.0, float, True)
            self.zoplot(y[mi])
            self.voplot(x[mi])
            self.voplot(x[r[0]])
            self.voplot(x[r[1]])
        # plot zero line
        self.zoplot()
        axes.set_title('Processed Signals')
        axes.set_xlabel(xTitle)
        axes.set_ylabel('Voltage, V')
        axes.legend(loc='best') 
        # force an image redraw
        self.draw()
 
    def plotXsub(self):
        """Plots processed signals vs Xsub"""
        if self.data is None :
            return
        self.execInitScript()
        axes = self.mplWidget.canvas.ax
        self.clearPicture()
        # draw chart
        indexes = self.listWidget.selectedIndexes()
        xTitle = 'X\', milliRadians'
        for i in indexes :
            row = i.row()
            x,y,index = self.readSignal(row)
            xx = x[index]
            yy = -1.0*y[index]
            axes.plot(xx, yy, label='jet '+str(row))
            #axes.plot(xx, gaussfit(xx, yy), '--', label='gauss '+str(row))
            pass
        # plot zero line
        axes.plot(axes.get_xlim(), [0.0,0.0], color='k')
        # decorate the plot
        axes.grid(True)
        axes.set_title('Elementary jet profile')
        axes.set_xlabel(xTitle)
        axes.set_ylabel('Signal, mkA')
        axes.legend(loc='best') 
        self.mplWidget.canvas.draw()

    def calculateEmittance(self):
        def plot(*args, **kwargs):
            axes = self.mplWidget.canvas.ax
            axes.plot(*args, **kwargs)
            #zoplot()
            #xlim = axes.get_xlim()
            #axes.plot(xlim, [0.0,0.0], color='k')
            #axes.set_xlim(xlim)
            axes.grid(True)
            axes.legend(loc='best') 
            self.mplWidget.canvas.draw()

        def draw():
            self.mplWidget.canvas.draw()

        def zoplot(v=0.0, color='k'):
            axes = self.mplWidget.canvas.ax
            xlim = axes.get_xlim()
            axes.plot(xlim, [v, v], color=color)
            axes.set_xlim(xlim)

        def voplot(v=0.0, color='k'):
            axes = self.mplWidget.canvas.ax
            ylim = axes.get_ylim()
            axes.plot([v, v], ylim, color=color)
            axes.set_ylim(ylim)

        def cls():
            self.clearPicture()
            
        if self.data is None :
            return
        nx = len(self.fileNames) 
        if nx <= 0 :
            return
        self.execInitScript()
        # calculate common values
        # x0
        x0 = np.zeros(nx-1)                         # [mm] X0 coordinates of scans
        ndh = np.zeros(nx-1)                        # [mm] displacement of analyzer slit (number n) from axis
        flag = self.readParameter(0, 'autox0', False)
        for i in range(1, nx) :
            if flag:
                x0[i-1] = self.readParameter(i, 'x0', 0.0, float, select='auto')
            else:
                x0[i-1] = self.readParameter(i, 'x0', 0.0, float)
            ndh[i-1] = self.readParameter(i, 'ndh', 0.0, float)
            #print('%d ndh %f'%(i,ndh[i-1]))
        x0c = np.zeros(nx-1)                        # [mm] X0 coordinates of scans
        for i in range(1, nx) :
            x0c[i-1] = self.readParameter(i, 'x0', 0.0, float, select='auto')
        #R  = 2.0e5        ; Ohm   Resistor for beamlet scaner FC
        #d1 = 0.4          ; mm    Analyzer hole diameter
        #d2 = 0.5          ; mm    Collector Slit Width
        #l1 = 213.0        ; mm    Distance From emission hole to analyzer hole
        #l2 = 200.0        ; mm    Distance From analyzer hole to slit collector
        # R
        R = self.readParameter(0, 'R', 2.0e5, float)    # [Ohm] Faraday cup load rezistior
        # l1
        l1 = self.readParameter(0, 'l1', 213.0, float)  # [mm] distance from source to analyzer aperture
        # l2
        l2 = self.readParameter(0, 'l2', 200.0, float)  # [mm] analyzer base
        # d1 and hole area
        d1 = self.readParameter(0, 'd1', 0.4, float)    # [mm] analyzer hole diameter
        a1 = np.pi*d1*d1/4.0                            # [mm**2] analyzer hole area    
        # d2
        d2 = self.readParameter(0, 'd2', 0.5, float)    # [mm] analyzer slit width
        printl('', stamp=False)
        printl('Emittance calculation using parameters:')
        printl('R=%f l1=%f l2=%f d1=%f d2=%f'%(R,l1,l2,d1,d2))
        # calculate maximum and integral profiles
        profilemax = np.zeros(nx-1)
        profileint = np.zeros(nx-1)
        for i in range(1, nx) :
            try:
                x,y,index = self.readSignal(i)           # x - [milliRadians] y - [mkA]
                yy = y[index]
                xx = x[index]
                h = np.where(np.diff(xx) != 0.0)[0]
                xx = xx[h]
                yy = yy[h]
                profilemax[i-1] = -1.0 * np.min(yy)      # [mkA]
                k = 1.0
                if xx[0] < xx[-1]:
                    k = -1.0
                # simps() returns nan if x of 2 points coincide
                #profileint[i-1] = k * scipy.integrate.simps(yy,xx) * l2 / d2 /1000.0  # [mkA] 1000.0 from milliradians
                # integrate by rectangles method
                profileint[i-1] = k * np.sum(yy[:-1]*np.diff(xx)) * l2 / d2 /1000.0  # [mkA] 1000.0 from milliradians
                #print(profileint[i-1])
            except:
                pass
        # sort in x0 increasing order
        ix0 = np.argsort(x0)
        #print(ix0)
        x0s = x0[ix0]
        profileint = profileint[ix0]
        profilemax = profilemax[ix0]
        # remove average x
        #xavg = simps(x0s * profilemax, x0s) / simps(profilemax, x0s)
        xavg = simps(x0s * profileint, x0s) / simps(profileint, x0s)
        print('Average X0 %f mm'%xavg)
        x0s = x0s - xavg
        # calculate total current
        index = np.where(x0s >= 0.0)[0]
        Ir = simps(x0s[index]*profileint[index], x0s[index])*2.0*np.pi/a1/1000.0
        print('Total current right %f [mA]'%Ir)
        index = np.where(x0s <= 0.0)[0]
        Il = -1.0*simps(x0s[index]*profileint[index], x0s[index])*2.0*np.pi/a1/1000.0
        print('Total current left %f [mA]'%Il)
        I = (Il + Ir)/2.0
        printl('Total current %f [mA]'%I)
        # save profile data
        folder = self.folderName
        fn = os.path.join(str(folder), 'InegralProfile.txt')
        np.savetxt(fn, np.array([x0,profileint]).T, delimiter='; ' )
        fn = os.path.join(str(folder), 'MaximumProfile.txt')
        np.savetxt(fn, np.array([x0,profilemax]).T, delimiter='; ' )
        # plot profiles
        axes = self.mplWidget.canvas.ax
        # plot integral profile
        if int(self.comboBox.currentIndex()) == 0:
            self.clearPicture()
            axes.plot(x0s, profileint, 'd-', label='Integral Profile')
            #axes.plot(x0s, gaussfit(x0s,profileint,x0s), '--', label='Gaussian fit')
            axes.grid(True)
            axes.set_title('Integral profile')
            axes.set_xlabel('X0, mm')
            axes.set_ylabel('Beamlet current, mkA')
            axes.legend(loc='best') 
            self.mplWidget.canvas.draw()
            #return
        # plot maximal profile
        if int(self.comboBox.currentIndex()) == 1:
            self.clearPicture()
            axes.plot(x0s, profilemax, 'o-', label='Maximum Profile')
            #axes.plot(x0s, gaussfit(x0s,profilemax,x0s), '--', label='Gaussian fit')
            axes.grid(True)
            axes.set_title('Maximum profile')
            axes.set_xlabel('X0, mm')
            axes.set_ylabel('Maximal current, mkA')
            axes.legend(loc='best') 
            self.mplWidget.canvas.draw()
            #return
        # calculate emittance contour plot
        # number of points for emittance matrix
        N = 300
        # calculate nx-1 x N arrays
        # X0 [mm]
        X0 = np.zeros((N,nx-1), dtype=np.float64)
        # X0' [milliRadians]
        Y0 = np.zeros((N,nx-1), dtype=np.float64)
        # current density [?]
        Z0 = np.zeros((N,nx-1), dtype=np.float64)
        # selected subarrays of data points
        v = []
        xsmin = 1e99
        xsmax = -1e99
        flag = self.readParameter(0, 'autox0', False)
        for i in range(1, nx) :
            if flag:
                X0[:,i-1] = self.readParameter(i, 'x0', 0.0, float, select='auto') - xavg
            else:
                X0[:,i-1] = self.readParameter(i, 'x0', 0.0, float) - xavg
            x,y,index = self.readSignal(i)           # x in [milliRadians]; y < 0.0 in [mkA]
            # center the plot over X0
            x = x - xavg/l1 * 1000.0
            v.append((x[index], -y[index]))
            xsmin = min([xsmin, x[index].min()])
            xsmax = max([xsmax, x[index].max()])
        # X0' range array
        xs = np.linspace(xsmin, xsmax, N)
        # fill data arrays
        for i in range(nx-1) :
            Y0[:,i] = xs
            x = v[i][0]
            y = v[i][1]
            index = np.unique(x, return_index=True)[1]
            #Z0[:,i] = np.interp(Y0[:,i], v[i][0], v[i][1])
            f = interp1d(x[index], y[index], kind='cubic', bounds_error=False, fill_value=0.0)
            #f = interp1d(x, y, kind='linear', bounds_error=False, fill_value=0.0)
            Z0[:,i] = f(Y0[:,i])
        # sort data according rising x0
        X1 = X0.copy()
        Y1 = Y0.copy()
        Z1 = Z0.copy()
        for i in range(nx-1) :
            X1[:,ix0[i]] = X0[:,i]
            Y1[:,ix0[i]] = Y0[:,i]
            Z1[:,ix0[i]] = Z0[:,i]
        # remove negative data
        Z1[Z1 < 0.0] = 0.0
        # debug plot 6
        if int(self.comboBox.currentIndex()) == 6:
            self.clearPicture()
            axes.contour(X1, Y1, Z1)
            axes.grid(True)
            axes.set_title('Calculated data')
            self.mplWidget.canvas.draw()
            return
        # reduce regular divergence
        for i in range(nx-1) :
            x = v[i][0]
            y = v[i][1]
            index = np.unique(x, return_index=True)[1]
            f = interp1d(x[index], y[index], kind='cubic', bounds_error=False, fill_value=0.0)
            # using calculated X0
            Z1[:,ix0[i]] = f(Y0[:,ix0[i]] + x0c[i]/l1*1000.0)
            #Z1[:,ix0[i]] = f(Y0[:,ix0[i]] + X0[:,ix0[i]]/l1*1000.0)
        # remove negative data
        Z1[Z1 < 0.0] = 0.0
        # debug plot 7
        if int(self.comboBox.currentIndex()) == 7:
            self.clearPicture()
            axes.contour(X1, Y1, Z1)
            axes.grid(True)
            axes.set_title('Regular divergence reduced')
            self.mplWidget.canvas.draw()
            return
        # debug plot 13
        if int(self.comboBox.currentIndex()) == 13:
            cls()
            indexes = self.listWidget.selectedIndexes()
            for j in indexes:
                k = j.row()             
                plot(Y1[:,k-1], Z1[:,k-1], label='-d'+str(k))
                r = self.readParameter(k-1, 'range')
                m = self.readParameter(k-1, 'minindex')
                v = self.readParameter(k-1, 'minvoltage')/R*1.0e6
                s = self.readParameter(k-1, "scale", 1.0, float)
                h = self.readParameter(k-1, "ndh", 0.0, float)
                print('i=%d v=%f r=%s'%(m,(h - s*v) / l2 * 1000.0,str(r)))
            return
        # calculate NxN array
        X = np.zeros((N, N), dtype=np.float64)
        Y = np.zeros((N, N), dtype=np.float64)
        Z = np.zeros((N, N), dtype=np.float64)
        for i in range(N) :
            X[i,: ] = np.linspace(x0.min(), x0.max(), N)
        for i in range(N) :
            Y[:,i] = xs
        for i in range(N) :
            #Z[i,:] = np.interp(X[i,:], X0[i,:], Z0[i,:])
            x = X1[i,:]
            y = Z1[i,:]
            index = np.unique(x, return_index=True)[1]
            f = interp1d(x[index], y[index], kind='cubic', bounds_error=False, fill_value=0.0)
            #f = interp1d(X1[i,:], Z1[i,:], kind='linear', bounds_error=False, fill_value=0.0)
            Z[i,:] = f(X[i,:])
        # remove negative currents
        Z[Z < 0.0] = 0.0
        # debug plot 14
        if int(self.comboBox.currentIndex()) == 14:
            self.clearPicture()
            axes.contour(X, Y, Z)
            axes.grid(True)
            axes.set_title('N x N no divergence')
            self.mplWidget.canvas.draw()
            return
        # return regular divergence back
        for i in range(N) :
            #Z[:,i] = np.interp(Y[:,i] - X[:,i]/l1*1000.0, Y[:,i], Z[:,i])
            x = Y[:,i]
            y = Z[:,i]
            index = np.unique(x, return_index=True)[1]
            f = interp1d(x[index], y[index], kind='cubic', bounds_error=False, fill_value=0.0)
            #f = interp1d(Y[:,i], Z[:,i], kind='linear', bounds_error=False, fill_value=0.0)
            Z[:,i] = f(Y[:,i] - X[:,i]/l1*1000.0)
        # remove negative currents
        Z[Z < 0.0] = 0.0
        # calculate emittance values
        q=1.6e-19        # [Q] electron charge
        m=1.6726e-27     # [kg]  proton mass
        c=2.9979e8       # [m/s] speed of light
        #U=32.7*1000.0   # [V] beam energy
        U = self.readParameter(0, 'energy', 32000.0, float)
        printl('Beam energy U=%f'%U)
        beta = np.sqrt(2.0*q*U/m)/c
        # RMS Emittance
        zt = np.sum(Z)
        XZ = X*Z
        YZ = Y*Z
        Xavg = np.sum(XZ)/zt
        Yavg = np.sum(YZ)/zt
        # subtract average values 
        X = X - Xavg
        Y = Y - Yavg
        XYavg = np.sum(X*Y*Z)/zt
        XXavg = np.sum(X*XZ)/zt
        YYavg = np.sum(Y*YZ)/zt
        RMS = np.sqrt(XXavg*YYavg-XYavg*XYavg)
        XX1avg = np.sum((X-Xavg)*(X-Xavg)*Z)/zt
        YY1avg = np.sum((Y-Yavg)*(Y-Yavg)*Z)/zt
        RMS1 = np.sqrt(XX1avg*YY1avg)
        print('Xavg=%f Yavg=%f'%(Xavg,Yavg))
        print('RMS=%f RMS1=%f'%(RMS*beta,RMS1*beta))
        printl('Normalized RMS Emittance %5.3f Pi*mm*mrad'%(RMS*beta))

        # save data to text file
        fn = os.path.join(str(folder), _progName + '_PlotX.gz')
        np.savetxt(fn, X, delimiter='; ' )
        fn = os.path.join(str(folder), _progName + '_PlotY.gz')
        np.savetxt(fn, Y, delimiter='; ' )
        fn = os.path.join(str(folder), _progName + '_PlotZ.gz')
        np.savetxt(fn, Z, delimiter='; ' )

        nz = 100
        zl = np.linspace(0.0, Z.max(), nz)
        zi = np.zeros(nz)
        zn = np.zeros(nz)
        zr = np.zeros(nz)

        for i in range(nz):
            mask = Z >= zl[i]
            #print(len(index))
            zn[i] = np.sum(mask)
            za = Z[mask]
            xa = X[mask]
            ya = Y[mask]
            zt = np.sum(za)
            zi[i] = zt
            xys = np.sum(xa*ya*za)/zt
            xxs = np.sum(xa*xa*za)/zt
            yys = np.sum(ya*ya*za)/zt
            #print(xxs*yys-xys*xys)
            zr[i] = np.sqrt(max([xxs*yys-xys*xys, 0.0]))

        # levels to draw
        #fractions = np.array([0.5,0.7,0.9])    # fraction of the beam current
        fractions = np.array(self.readParameter(0, 'fractions', [0.5,0.7,0.9]))
        levels = fractions*0.0
        emit = fractions*0.0
        rms = fractions*0.0
        zs = np.sum(Z)
        for i in range(len(fractions)):
            index = np.where(zi >= fractions[i]*zs)[0]
            n = index.max()
            levels[i] = zl[n]
            emit[i] = zn[n]
            rms[i] = zr[n]
        
        emit = emit*(X[0,0]-X[0,1])*(Y[0,0]-Y[1,0])/np.pi*beta
        rms = rms*beta
        printl('Current  Normalized emittance      Normalized RMS emittance')
        for i in range(len(levels)):
            printl('%2.0f %%     %5.3f Pi*mm*milliradians  %5.3f Pi*mm*milliradians'%(fractions[i]*100.0,emit[i],rms[i]))
        # plot contours
        if int(self.comboBox.currentIndex()) == 2:
            self.clearPicture()
            axes.contour(X, Y, Z, linewidths=1.0)
            axes.grid(True)
            axes.set_title('Emittance contour plot')
            #axes.set_ylim([xsmin,xsmax])
            axes.set_xlabel('X0, mm')
            axes.set_ylabel('X0\', milliRadians')
            axes.annotate('Total current %4.1f mA'%I + '; Normalized RMS Emittance %5.3f Pi*mm*mrad'%(RMS*beta),
                          xy=(.5, .2), xycoords='figure fraction',
                          horizontalalignment='center', verticalalignment='top',
                          fontsize=11)
            #axes.annotate(' Normalized RMS Emittance %5.3f Pi*mm*mrad'%(RMS*beta),
            #              xy=(.5, .85), xycoords='figure fraction',
            #              horizontalalignment='center', verticalalignment='top',
            #              fontsize=12)
            self.mplWidget.canvas.draw()
        # plot filled contours
        if int(self.comboBox.currentIndex()) == 3:
            self.clearPicture()
            axes.contourf(X, Y, Z)
            axes.grid(True)
            axes.set_title('Emittance color plot')
            #axes.set_ylim([xsmin,xsmax])
            axes.set_xlabel('X0, mm')
            axes.set_ylabel('X0\', milliRadians')
            axes.annotate('Total current %4.1f mA'%I + '; Normalized RMS Emittance %5.3f Pi*mm*mrad'%(RMS*beta),
                          xy=(.5, .2), xycoords='figure fraction',
                          horizontalalignment='center', verticalalignment='top',
                          fontsize=11, color='white')
            self.mplWidget.canvas.draw()
        # plot levels
        if int(self.comboBox.currentIndex()) == 4:
            self.clearPicture()
            CS = axes.contour(X, Y, Z, linewidths=1.0, levels=levels[::-1])
            axes.grid(True)
            axes.set_title('Emittance contours for levels')
            #axes.set_ylim([xsmin,xsmax])
            axes.set_xlabel('X, mm')
            axes.set_ylabel('X\', milliRadians')
            labels = ['%2d %% of current'%(fr*100) for fr in np.sort(fractions)[::-1]]
            for i in range(len(labels)):
                CS.collections[i].set_label(labels[i])
            axes.legend(loc='upper left')
            #axes.annotate('some text here',(1.4,1.6))
            axes.annotate('Total current %4.1f mA'%I + '; Normalized RMS Emittance %5.3f Pi*mm*mrad'%(RMS*beta),
                          xy=(.5, .2), xycoords='figure fraction',
                          horizontalalignment='center', verticalalignment='top',
                          fontsize=11)
            self.mplWidget.canvas.draw()
        
    def saveSettings(self, folder='', fileName=_settingsFile, local=False) :
        fullName = os.path.join(str(folder), fileName)
        dbase = shelve.open(fullName, flag='n')
        # data folder
        dbase['folder'] = self.folderName
        # default smooth
        dbase['smooth'] = int(self.spinBox.value())
        # scan voltage channel number
        dbase['scan'] = int(self.spinBox_2.value())
        # result combo
        dbase['result'] = int(self.comboBox.currentIndex())
        comboitems = [self.comboBox_2.itemText(count) for count in range(self.comboBox_2.count())]
        if len(comboitems) > 10 :
            comboitems = comboitems[:10]
        dbase['history'] = comboitems
        # save paramsAuto
        dbase['paramsAuto'] = self.paramsAuto
        dbase.close()
        print('Configuration saved to %s'%fullName)
        return True
   
    def restoreSettings(self, folder='', fileName=_settingsFile, local=False) :
        # execute init script
        self.execInitScript(folder)
        # read saved settings
        try :
            fullName = os.path.join(str(folder), fileName)
            dbase = shelve.open(fullName)
            # global settings
            if not local :
                # data folder
                self.folderName = dbase['folder']
                # history
                self.comboBox_2.clear()
                self.comboBox_2.addItems(dbase['history'])
            # default smooth
            self.spinBox.setValue(dbase['smooth'])
            # result combo
            self.comboBox.setCurrentIndex(dbase['result'])
            # scan voltage channel number
            self.spinBox_2.setValue(dbase['scan'])
            # restore paramsAuto
            self.paramsAuto = dbase['paramsAuto']
            dbase.close()
            print('Configuration restored from %s'%fullName)
            return True
        except :
            (type, value, traceback) = sys.exc_info()
            print('Exception : %s'%value)
            print('Configuration file %s restore error.'%fullName)
            return False

    def execInitScript(self, folder=None, fileName=_initScript):
        if folder is None :
            folder = self.folderName
        try:
            fullName = os.path.join(str(folder), fileName)
            exec(open(fullName).read(), globals(), locals())
            print('Init script %s executed'%fullName)
        except:
            (type, value, traceback) = sys.exc_info()
            print('Exception : %s'%value)
            print('Init script %s error'%fullName)

if __name__ == '__main__':
    # create the GUI application
    app = QApplication(sys.argv)
    # instantiate the main window
    dmw = DesignerMainWindow()
    app.aboutToQuit.connect(dmw.onQuit)
    # show it
    dmw.show()
    # start the Qt main loop execution, exiting from this script
    # with the same return code of Qt application
    sys.exit(app.exec_())