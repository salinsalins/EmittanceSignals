# coding: utf-8
'''
Created on Jul 2, 2017

@author: sanin
'''
# used to parse files more easily
from __future__ import with_statement
from __future__ import print_function

import os.path
import shelve
import sys

#from my_isfread import my_isfread as isfread
from findRegions import findRegions as findRegions
from findRegions import restoreFromRegions as restoreFromRegions
from smooth import smooth
from printl import printl 
from readTekFiles import readTekFiles
#from gaussfit import gaussfit 

try:
    from PyQt4.QtGui import QMainWindow
    from PyQt4.QtGui import QApplication
    from PyQt4.QtGui import qApp
    from PyQt4.QtGui import QFileDialog
    from PyQt4.QtGui import QTableWidgetItem
    from PyQt4 import uic
except:
    from PyQt5.QtWidgets import QMainWindow
    from PyQt5.QtWidgets import QApplication
    from PyQt5.QtWidgets import qApp
    from PyQt5.QtWidgets import QFileDialog
    from PyQt5.QtWidgets import QTableWidgetItem
    from PyQt5 import uic

import numpy as np
#import scipy.integrate
from scipy.integrate import trapz
from scipy.interpolate import interp1d

_progName = 'Emittance'
_progVersion = '_4_1'
_settingsFile = _progName + '_init.dat'
_initScript =  _progName + '_init.py'
_logFile =  _progName + '_log.log'

class DesignerMainWindow(QMainWindow):
    """Customization for Qt Designer created window"""
    def __init__(self, parent = None):
        # initialization of the superclass
        super(DesignerMainWindow, self).__init__(parent)
        # setup the GUI --> function generated by pyuic4
        uic.loadUi('Emittance.ui', self)
        #self.setupUi(self)
        # connect the signals with the slots
        #self.pushButton.clicked.connect(self.plotRawSignals)
        #self.pushButton_3.clicked.connect(self.plotProcessedSignals)
        self.actionOpen.triggered.connect(self.selectFolder)
        self.pushButton_2.clicked.connect(self.selectFolder)
        self.actionQuit.triggered.connect(qApp.quit)
        self.pushButton_4.clicked.connect(self.processFolder)
        #self.pushButton_5.clicked.connect(self.plotElementaryJet)
        self.pushButton_6.clicked.connect(self.pushPlotButton)
        self.pushButton_7.clicked.connect(self.erasePicture)
        self.comboBox_2.currentIndexChanged.connect(self.selectionChanged)
        #self.pushButton_8.clicked.connect(self.flipStopFlag)
        # variables definition
        self.stopFlag = False
        self.data = None
        self.paramsAuto = None
        self.fleNames = []
        self.folderName = ''
        printl(_progName + _progVersion + ' started')
        # restore global settings from default location
        self.restoreSettings()
        # add dataFolder to history
        i = self.comboBox_2.findText(self.folderName)
        if i >= 0:
            self.comboBox_2.setCurrentIndex(i)
        else:
            # add item to history  
            self.comboBox_2.insertItem(-1, self.folderName)
            self.comboBox_2.setCurrentIndex(0)
        # read data files
        self.parseFolder(folder = self.folderName)
        # restore local settings
        if not self.restoreSettings(folder = self.folderName, local=True):
            self.processFolder()
    
    def selectFolder(self):
        """Opens a dataFolder select dialog"""
        # open the dialog and get the selected dataFolder
        folder = self.folderName
        fileOpenDialog = QFileDialog(caption='Select directory with data files', directory=folder)
        # select folder, not file
        dataFolder = fileOpenDialog.getExistingDirectory()
        # if a dataFolder is selected
        if dataFolder:
            if self.folderName == dataFolder:
                return
            i = self.comboBox_2.findText(dataFolder)
            if i >= 0:
                self.comboBox_2.setCurrentIndex(i)
            else:
                # add item to history  
                self.comboBox_2.setCurrentIndex(-1)
                self.comboBox_2.insertItem(-1, dataFolder)
                self.comboBox_2.setCurrentIndex(0)
    
    def selectionChanged(self, i):
        #print("Current index %s. Selection changed %s"%(i,str(self.comboBox_2.currentText())))
        if i < 0:
            return
        dataFolder = str(self.comboBox_2.currentText())
        if self.folderName != dataFolder:
            #self.folderName = self.comboBox_2.currentText()
            #print('New folder selected %s'%dataFolder)
            # parse selected folder
            #self.folderName = dataFolder
            self.parseFolder(dataFolder)
            # restore local settings
            if not self.restoreSettings(folder=dataFolder, local=True):
                self.processFolder()
 
    def onQuit(self) :
        # save settings to folder
        self.saveSettings(folder = self.folderName)
        # save global settings
        self.saveSettings()

    def clearPicture(self, force=False):
        if force or self.checkBox.isChecked():
            # clear the axes
            self.mplWidget.canvas.ax.clear()
        
    def erasePicture(self):
        self.mplWidget.canvas.ax.clear()
        self.mplWidget.canvas.draw()

    def flipStopFlag(self):
        self.stopFlag = not self.stopFlag
        
    def removeInersections(self, y1, y2, index):
        # calculate relative first derivatives
        d1 = np.diff(y1)
        d1 = np.append(d1, d1[-1])
        d2 = np.diff(y2)
        d2 = np.append(d2, d2[-1])
        regout = []
        reg = findRegions(index)
        #print('Initial regions  %s'%str(reg))
        for r in reg:
            if y1[r[0]] > y2[r[0]] and y1[r[1]-1] < y2[r[1]-1]:
                if np.all(d1[r[0]:r[1]]*d2[r[0]:r[1]] < 0.0):
                    continue
            if y1[r[0]] < y2[r[0]] and y1[r[1]-1] > y2[r[1]-1]:
                if np.all(d1[r[0]:r[1]]*d2[r[0]:r[1]] < 0.0):
                    continue
            regout.append(r)
        #print('Filtered regions %s'%str(regout))
        return regout

    def parseFolder(self, folder, mask='*.isf'):
        printl('Parsing folder %s'%folder)
        # read data
        self.data, self.fileNames = readTekFiles(folder, mask)
        # number of files
        nx = len(self.fileNames)
        if nx <= 0 :
            return
        printl('%s%s Parsing folder %s'%(_progName, _progVersion, folder), 
               fileName = os.path.join(str(folder), _logFile))
        # fill list with file names
        self.listWidget.clear()
        # short file names list
        names = [name.replace(folder, '')[1:] for name in self.fileNames]
        for i in range(nx):
            names[i] = '%3d - %s'%(i,names[i])
        # fill listWidget
        self.listWidget.addItems(names)
        self.folderName = folder
    
    def processFolder(self):
        def plot(*args, **kwargs):
            axes = self.mplWidget.canvas.ax
            axes.plot(*args, **kwargs)
            zoplot()
            axes.grid(True)
            axes.legend(loc='best') 
            self.mplWidget.canvas.draw()

        def draw():
            self.mplWidget.canvas.draw()

        def zoplot(v=0.0, color='k'):
            axes = self.mplWidget.canvas.ax
            xlim = axes.get_xlim()
            axes.plot(xlim, [v, v], color=color)
            axes.set_xlim(xlim)

        def voplot(v=0.0, color='k'):
            axes = self.mplWidget.canvas.ax
            ylim = axes.get_ylim()
            axes.plot([v, v], ylim, color=color)
            axes.set_ylim(ylim)

        def cls():
            self.clearPicture()
            
        axes = self.mplWidget.canvas.ax
        folder = self.folderName
        printl('Processing folder %s'%folder)
        print('Reading data ...')
        # read data array
        data,files  = readTekFiles(folder)
        # number of files
        nx = len(files)
        if nx <= 0 :
            print('Nothing to process')
            return False
        print('%d files fond'%nx)

        # Y size of data
        ny = len(data[0])
        # define arrays
        zero  = np.zeros((nx, ny), dtype=np.float64)
        weight = np.zeros((nx, ny), dtype=np.float64)
        # index array
        ix = np.arange(ny)
        
        # default sooth
        ns = 1
        try:
            ns = int(self.spinBox.value())
        except:
            pass
        
        # default parameters array
        params = [{'smooth':ns, 'offset':0.0, 'zero':np.zeros(ny), 'scale': 1.95} for i in range(nx)]
        
        # sooth data array
        print('Smoothing data ...')
        for i in range(nx) :
            y = data[i,:]
            smooth(y, params[i]['smooth'])
            data[i,:] = y
        
        # channel 0 is by default scan voltage 
        x = data[0,:].copy()
        # smooth 
        smooth(x, params[0]['smooth']*2)
        # find longest monotonic region of scan voltage
        xdiff = np.diff(x)
        xdiff = np.append(xdiff, xdiff[-1])
        mask = xdiff >= 0.0
        regions = findRegions(np.where(mask)[0])         
        # find longest region
        xr = [0,1]
        xincrease = True
        for r in regions:
            if r[1]-r[0] >= xr[1]-xr[0]:
                xr = r
                xincrease = True
        mask = xdiff <= 0.0
        regions = findRegions(np.where(mask)[0])         
        for r in regions:
            if r[1]-r[0] >= xr[1]-xr[0]:
                xr = r
                xincrease = False
        xi = np.arange(xr[0], xr[1])
        params[0]['range'] = xr
        print('Scan voltage region %s'%str(xr))
        # debug draw 8 Scan voltage region
        if int(self.comboBox.currentIndex()) == 8:
            self.clearPicture()
            axes.set_title('Scan voltage region')
            axes.set_xlabel('Point index')
            axes.set_ylabel('Voltage, V')
            axes.plot(ix, x, label='Scan voltage')
            axes.plot(ix[xi], x[xi], '.', label='Region')
            zoplot()
            axes.grid(True)
            axes.legend(loc='best') 
            self.mplWidget.canvas.draw()
                    
        # auto process data for zero line and offset
        print('Processing zero line ...')
        for i in range(1,nx-1) :
            #print('Channel %d'%(i))
            y1 = data[i,:].copy()
            offset1 = params[i]['offset']
            y1 = y1 - offset1
            y2 = data[i+1,:].copy()
            offset2 = params[i+1]['offset']
            y2 = y2 - offset2
            # double smooth because zero line is slow 
            smooth(y1, params[i]['smooth']*2)
            smooth(y2, params[i+1]['smooth']*2)
            # offsets calculated from upper 10%
            y1min = np.min(y1)
            y1max = np.max(y1)
            dy1 = y1max - y1min
            y2min = np.min(y2)
            y2max = np.max(y2)
            dy2 = y2max - y2min
            dy = max([dy1, dy2])
            i1 = np.where(y1 > (y1max - 0.1*dy))[0]
            o1 = np.average(y1[i1])
            #print('Offset 1 %f'%o1)
            i2 = np.where(y2 > (y2max - 0.1*dy))[0]
            o2 = np.average(y2[i2])
            #print('Offset 2 %f'%o2)
            # debug draw 9 Offset calculation
            if int(self.comboBox.currentIndex()) == 9 :
                indexes = self.listWidget.selectedIndexes()
                if (len(indexes) > 0) and (i == indexes[0].row()):
                    self.clearPicture()
                    axes.set_title('Offset calculation')
                    axes.set_xlabel('Point index')
                    axes.set_ylabel('Signal, V')
                    axes.plot(ix, y1,'r', label='raw'+str(i))
                    zoplot(o1,'r')
                    axes.plot(ix, y2,'b', label='raw'+str(i+1))
                    zoplot(o2,'b')
                    axes.plot(i1, y1[i1], '.')
                    axes.plot(i2, y2[i2], '.')
                    axes.grid(True)
                    axes.legend(loc='best') 
                    self.mplWidget.canvas.draw()
            # correct y2 and offset2 for calculated offsets
            y2 = y2 - o2 + o1
            offset2 = offset2 + o2 - o1 
            # zero line = where 2 signals are equal
            mask = np.abs(y1 - y2) < 0.05*dy1
            index = np.where(mask)[0]
            #print(findRegionsText(index))
            # filter signal intersections
            index = restoreFromRegions(findRegions(index, 50, 300, 100, 100, length=ny))
            if len(index) <= 0:
                index = np.where(mask)[0]
            # new offset
            offset = np.average(y2[index] - y1[index])
            #print('Offset for channel %d = %f'%((i+1), offset))
            # shift y2 and offset2
            y2 = y2 - offset
            offset2 = offset2 + offset 
            # save processed offset
            params[i+1]['offset'] = offset2
            # index with new offset
            #print('4% index with corrected offset')
            mask = np.abs(y1 - y2) < 0.04*dy1
            index = np.where(mask)[0]
            #print(findRegionsText(index))
            # filter signal intersection
            regions = findRegions(index, 50)
            index = restoreFromRegions(regions, 0, 150, length=ny)
            #print(findRegionsText(index))
            # choose largest values
            mask[:] = False
            mask[index] = True
            mask3 = np.logical_and(mask, y1 >= y2)
            index3 = np.where(mask3)[0]
            # update zero for all channels
            for j in range(1,nx) :
                w = 1.0/((abs(i - j))**2 + 1.0)
                zero[j,index3] = (zero[j,index3]*weight[j,index3] + y1[index3]*w)/(weight[j,index3] + w)
                weight[j,index3] += w
            mask4 = np.logical_and(mask, y1 <= y2)
            index4 = np.where(mask4)[0]
            # update zero for all channels
            for j in range(1,nx) :
                w = 1.0/((abs(i + 1 - j))**2 + 1.0)
                zero[j,index4] = (zero[j,index4]*weight[j,index4] + y2[index4]*w)/(weight[j,index4] + w)
                weight[j,index4] += w
            # debug plot 9 zero line intermediate results
            if int(self.comboBox.currentIndex()) == 10 :
                indexes = self.listWidget.selectedIndexes()
                if len(indexes) > 0:
                    k = indexes[0].row()             
                    self.clearPicture()
                    axes.set_title('Zero line calculation')
                    axes.set_xlabel('Point index')
                    axes.set_ylabel('Signal, V')
                    axes.plot(ix, data[k,:], label='raw'+str(k))
                    z = zero[k].copy() + params[k]['offset']
                    smooth(z, params[k]['smooth']*2)
                    axes.plot(ix, z, label='zero'+str(k))
                    axes.grid(True)
                    axes.legend(loc='best') 
                    self.mplWidget.canvas.draw()
            pass
        # save processed zero line
        for i in range(nx) :
            params[i]['zero'] = zero[i]
        
        # determine signal area
        print('Processing signals ...')
        for i in range(1, nx) :
            #print('Channel %d'%i)
            y0 = data[i,:].copy()[xi]
            smooth(y0, params[i]['smooth'])
            z = zero[i].copy()[xi] + params[i]['offset']
            smooth(z, params[i]['smooth']*2)
            y = y0 - z
            ymin = np.min(y)
            ymax = np.max(y)
            dy = ymax - ymin
            mask = y < (ymax - 0.6*dy)
            index = np.where(mask)[0]
            ra = findRegions(index)
            params[i]['range'] = xr
            # determine scale
            is1 = xi[0]
            is2 = xi[-1]
            if len(ra) >= 1:
                is1 = np.argmin(y[ra[0][0]:ra[0][1]]) + ra[0][0] + xi[0]
            if len(ra) >= 2:
                is2 = np.argmin(y[ra[1][0]:ra[1][1]]) + ra[1][0] + xi[0]
            params[i]['scale'] = 10.0/(x[is2] - x[is1])   # [mm/Volt]
            if np.abs(x[is1]) < np.abs(x[is2]) :
                index = is1
            else:
                index = is2
            params[i]['minindex'] = index
            params[i]['minvoltage'] = x[index]
            di = int(abs(is2 - is1)/2.0)
            ir1 = max([xi[ 0], index - di])
            ir2 = min([xi[-1], index + di])
            params[i]['range'] = [ir1, ir2]
            #print('raw scale %f mm/V'%params[i]['scale'], end='  ')
            #print('minindex=%d Umin=%f V'%(index,x[index]), end='  ')
            #print('range %s'%str(params[i]['range']))
            # debug draw 11 Range and scale calculation
            if int(self.comboBox.currentIndex()) == 11:
                indexes = self.listWidget.selectedIndexes()
                if (len(indexes) > 0) and (i == indexes[0].row()):
                    self.clearPicture()
                    axes.set_title('Range and scale calculation')
                    axes.set_xlabel('Point index')
                    axes.set_ylabel('Signal, V')
                    axes.plot(xi, y, label='proc.s.'+str(i))
                    axes.plot(ix[ir1:ir2], y[ir1 - xi[0]:ir2 - xi[0]], '.', label='range'+str(i))
                    voplot(is1, 'r')
                    voplot(is2, 'b')
                    axes.grid(True)
                    axes.legend(loc='best') 
                    self.mplWidget.canvas.draw()
        
        # filter scales
        sc0 = np.array([params[i]['scale'] for i in range(1,nx)])
        sc = sc0.copy()
        asc = np.average(sc)
        ssc = np.std(sc)
        while ssc > 0.3*np.abs(asc):
            index1 = np.where(abs(sc - asc) <= 2.0*ssc)[0]
            index2 = np.where(abs(sc - asc) > 2.0*ssc)[0]
            sc[index2] = np.average(sc[index1])
            asc = np.average(sc)
            ssc = np.std(sc)
        for i in range(1,nx) :
            params[i]['scale'] = sc[i-1] 
            print('%3d'%i, end='  ')
            print('Imin=%d Umin=%f V'%(params[i]['minindex'], params[i]['minvoltage']), end='  ')
            print('range=%s'%str(params[i]['range']), end='  ')
            print('scale=%f mm/V'%params[i]['scale'])

        # common parameters
        print('Set common parameters ...')
        # Parameters of Measurements
        #R  = 2.0e5        ; Ohm    Resistor for beamlet scanner FC
        #d1 = 0.4          ; mm    Analyzer hole diameter
        #d2 = 0.5          ; mm    Collector Slit Width
        #l1 = 213.0        ; mm    Distance From emission hole to analyzer hole
        #l2 = 200.0        ; mm    Distance From analyzer hole to slit collector
        params[0]['R'] = 2.0e5
        params[0]['d1'] = 0.4
        params[0]['d2'] = 0.5
        l1 = 213.0
        params[0]['l1'] = l1
        l2 = 200.0
        params[0]['l2'] = l2
        
        # save to member variable
        self.paramsAuto = params

        # exec init script
        self.execInitScript()

        # X0 and ndh calculation
        l1 = self.readParameter(0, "l1", 213.0, float)
        l2 = self.readParameter(0, "l2", 200.0, float)
        x00 = np.zeros(nx-1)
        for i in range(1, nx) :
            s = self.readParameter(i, "scale", 2.0, float)
            u = self.readParameter(i, "minvoltage", 0.0, float)
            j = self.readParameter(i, "minindex", 0, int)
            x00[i-1] = -s*u*l1/l2
            print('%3d N=%d Umin=%f scale=%f X00=%f'%(i, j, u, s, x00[i-1]))
        npt = 0
        sp = 0.0
        nmt = 0
        sm = 0.0
        dx = x00.copy()*0.0
        #print('%3d X00=%f DX=%f'%(0, x00[0], 0.0))
        for i in range(1, nx-1) :
            dx[i] = x00[i] - x00[i-1]
            if dx[i] > 0.0:
                npt += 1
                sp += dx[i]
            if dx[i] < 0.0:
                nmt += 1
                sm += dx[i]
            #print('%3d X00=%f DX=%f'%(i, x00[i], dx[i]))
        #print('npt=%d %f nmt=%d %f %f'%(npt,sp/npt,nmt,sm/nmt,sp/npt-l1/l2*10.))
        x01 = x00.copy()
        h = x00.copy()*0.0
        for i in range(1, nx-1) :
            if npt > nmt :
                x01[i] = x01[i-1] + sp/npt
                if dx[i] > 0.0:
                    h[i] = h[i-1]
                else:
                    h[i] = h[i-1] + 10.0
            else:
                x01[i] = x01[i-1] + sm/nmt
                if dx[i] < 0.0:
                    h[i] = h[i-1]
                else:
                    h[i] = h[i-1] - 10.0
        x01 = x01 - np.average(x01)
        k = int(np.argmin(np.abs(x01)))
        h = h - h[k]
        for i in range(1, nx) :
            params[i]['ndh'] = h[i-1]
            s = self.readParameter(i, "scale", 2.0, float)
            u = self.readParameter(i, "minvoltage", 0.0, float)
            x01[i-1] = (h[i-1] - s*u)*l1/l2 
            params[i]['x0'] = x01[i-1] 
            print('%3d'%i, end='  ')
            print('X0=%f mm ndh=%4.1f mm'%(params[i]['x0'],params[i]['ndh']), end='  ')
            print('X00=%f mm DX=%f mm'%(x00[i-1], dx[i-1]))
        # debug draw 12 X0 calculation
        x0 = x01.copy()
        for i in range(1, nx) :
            x0[i-1] = self.readParameter(i, 'x0', 0.0, float)
        if int(self.comboBox.currentIndex()) == 12:
            self.clearPicture()
            axes.set_title('X0 calculation')
            axes.set_xlabel('Index')
            axes.set_ylabel('X0, mm')
            axes.plot(x01-x01[k], 'o-', label='X0 calculated')
            axes.plot(x0-x0[k], 'd-', label='X0 from parameters')
            axes.grid(True)
            axes.legend(loc='best') 
            self.mplWidget.canvas.draw()
        
        # save processed to member variable
        self.paramsAuto = params
        print('Auto parameters has been calculated')
        
        return True
                
    def readParameter(self, row, name, default=None, dtype=None, info=False, select=''):
        if name == 'zero':
            return self.readZero(row)
        vd = default
        t = 'default'
        v = vd
        try:
            va = self.paramsAuto[row][name]
            t = 'auto'
            v = va
        except:
            va = None
        try:
            vm = self.paramsManual[row][name]
            t = 'manual'
            v = vm
        except:
            vm = None
        if dtype is not None :
            v = dtype(v)
        if info :
            print('row:%d name:%s %s value:%s (default:%s auto:%s manual:%s)'%(row, name, t, str(v), str(vd), str(va), str(vm)))
        if select == 'manual':
            return vm
        if select == 'auto':
            return va
        if select == 'default':
            return vd
        return v

    def readZero(self, row):
        if self.data is None:
            return None
        try:
            z = self.paramsAuto[row]['zero'].copy()
        except:
            z = np.zeros_like(self.data[0])
        # manual zero line
        try:
            # manual regions
            zr = self.paramsManual[row]['zero']
            for zi in zr:
                try:
                    if zi[0] == -1 :
                        # linear interpolation
                        z0 = self.data[row, :].copy()
                        ns = self.readParameter(row, "smooth", self.spinBox.value(), int)
                        smooth(z0, ns)
                        of = self.readParameter(row, "offset", 0.0, float)
                        z0 = z0 - of # minus is correct !!!
                        y1 = z0[zi[1]]
                        y2 = z0[zi[2]]
                        z[zi[1]:zi[2]+1] = np.interp(np.arange(zi[1],zi[2]+1), [zi[1],zi[2]], [y1,y2])
                    if zi[0] > 0 :
                        z0 = self.data[zi[0], :].copy()
                        ns = self.readParameter(zi[0], "smooth", 1, int)
                        of = self.readParameter(zi[0], "offset", 0.0, float)
                        smooth(z0, 2*ns)
                        z[zi[1]:zi[2]] = z0[zi[1]:zi[2]] + of
                except:
                    pass
        except:
            pass
        return z

    def readSignal(self, row):
        if self.data is None :
            return
        #print('Processing %d'%row)
        # scan voltage
        u = self.data[0, :].copy()
        # smooth
        ns = self.readParameter(0, "smooth", 100, int)
        smooth(u, 2*ns)
        # signal
        y = self.data[row, :].copy()
        # smooth
        ns = self.readParameter(row, "smooth", 1, int)
        # offset
        of = self.readParameter(row, "offset", 0.0, float)
        # zero line
        z = self.readZero(row)
        # smooth
        smooth(y, ns)
        smooth(z, 2*ns)
        # subtract offset and zero
        y = y - z - of
        # load resistor
        R = self.readParameter(0, "R", 2.0e5, float)
        # convert signal to microAmperes
        y = y/R*1.0e6
        # signal region
        r0 = self.readParameter(0, "range", (0, len(y)))
        r = self.readParameter(row, "range", r0)
        index = np.arange(r[0],r[1])
        # scale
        s = self.readParameter(row, "scale", 1.0, float)
        # ndh
        ndh = self.readParameter(row, "ndh", 0.0, float)
        # scanner base
        l2 = self.readParameter(0, "l2", 200.0, float)
        # x' in milliRadians
        xsub = (ndh - s*u) / l2 * 1000.0
        return (xsub, y, index)

    def plot(self, *args, **kwargs):
        axes = self.mplWidget.canvas.ax
        axes.plot(*args, **kwargs)
        #zoplot()
        #xlim = axes.get_xlim()
        #axes.plot(xlim, [0.0,0.0], color='k')
        #axes.set_xlim(xlim)
        axes.grid(True)
        axes.legend(loc='best') 
        self.mplWidget.canvas.draw()

    def draw(self):
        self.mplWidget.canvas.draw()

    def zoplot(self, v=0.0, color='k'):
        axes = self.mplWidget.canvas.ax
        xlim = axes.get_xlim()
        axes.plot(xlim, [v, v], color=color)
        axes.set_xlim(xlim)

    def voplot(self, v=0.0, color='k'):
        axes = self.mplWidget.canvas.ax
        ylim = axes.get_ylim()
        axes.plot([v, v], ylim, color=color)
        axes.set_ylim(ylim)

    def cls(self):
        self.clearPicture()

    def getX(self):
        ix = self.spinBox_2.value()
        if ix >= 0:
            x = self.data[ix, :].copy()
            ns = self.readParameter(ix, "smooth", self.spinBox.value(), int, True)
            smooth(x, ns)
            xTitle = 'Scan Voltage, V'
        else:
            x = np.arange(len(self.data[0, :]))
            xTitle = 'Point index'
        return (x,xTitle)

    def plotRawSignals(self):
        self.execInitScript()
        self.clearPicture()
        if self.data is None :
            return
        # draw chart
        axes = self.mplWidget.canvas.ax
        x,xTitle = self.getX()
        indexes = self.listWidget.selectedIndexes()
        for i in indexes :
            row = i.row()
            y = self.data[row, :].copy()
            ns = self.readParameter(row, "smooth", self.spinBox.value(), int, True)
            smooth(y, ns)
            z = self.readZero(row) + self.readParameter(row, 'offset')
            axes.plot(x, y, label='raw '+str(row))
            axes.plot(x, z, label='zero'+str(row))
        axes.plot(axes.get_xlim(), [0.0,0.0], color='k')
        axes.grid(True)
        axes.set_title('Signals with zero line')
        axes.set_xlabel(xTitle)
        axes.set_ylabel('Signal Voltage, V')
        axes.legend(loc='best') 
        self.mplWidget.canvas.draw()

    def plotProcessedSignals(self):
        """Plots processed signals"""
        if self.data is None :
            return
        self.execInitScript()
        # clear the Axes
        self.clearPicture()
        x,xTitle = self.getX()
        # draw chart
        indexes = self.listWidget.selectedIndexes()
        axes = self.mplWidget.canvas.ax
        for i in indexes :
            row = i.row()
            u,y,index = self.readSignal(row)
            # convert back from microAmpers to volts
            y = y * self.readParameter(0, "R", 2.0e5, float) / 1.0e6
            # plot processed signal
            self.plot(x, y, label='proc '+str(row))
            # highlight signal region
            self.plot(x[index], y[index], label='range'+str(row))
            print('Signal %d'%row)
            # print parameters
            self.readParameter(row, "smooth", 1, int, True)
            self.readParameter(row, "offset", 0.0, float, True)
            self.readParameter(row, "scale", 0.0, float, True)
            self.readParameter(row, "x0", 0.0, float, True)
            self.readParameter(row, "ndh", 0.0, float, True)
            # range vertical lines
            r = self.readParameter(row, "range", (0,-1), None, True)
            self.voplot(x[r[0]])
            self.voplot(x[r[1]-1])
        # plot zero line
        self.zoplot()
        axes.set_title('Processed Signals')
        axes.set_xlabel(xTitle)
        axes.set_ylabel('Voltage, V')
        axes.legend(loc='best') 
        # force an image redraw
        self.draw()
 
    def plotElementaryJet(self):
        """Plot elementary jet profile"""
        if self.data is None :
            return
        self.execInitScript()
        axes = self.mplWidget.canvas.ax
        self.clearPicture()
        # draw chart
        indexes = self.listWidget.selectedIndexes()
        xTitle = 'X\', milliRadians'
        for i in indexes :
            row = i.row()
            x,y,index = self.readSignal(row)
            xx = x[index]
            yy = -1.0*y[index]
            axes.plot(xx, yy, label='jet '+str(row))
            #axes.plot(xx, gaussfit(xx, yy), '--', label='gauss '+str(row))
        # plot axis y=0
        axes.plot(axes.get_xlim(), [0.0,0.0], color='k')
        # decorate the plot
        axes.grid(True)
        axes.set_title('Elementary jet profile')
        axes.set_xlabel(xTitle)
        axes.set_ylabel('Signal, mkA')
        axes.legend(loc='best') 
        self.mplWidget.canvas.draw()

    def pushPlotButton(self):
        if self.data is None :
            return
        nx = len(self.fileNames) 
        if nx <= 0 :
            return
        
        if int(self.comboBox.currentIndex()) == 16:
            self.plotRawSignals()
            return
        if int(self.comboBox.currentIndex()) == 17:
            self.plotProcessedSignals()
            return
        if int(self.comboBox.currentIndex()) == 18:
            self.plotElementaryJet()
            return
        self.calculateEmittance()
    
    def calculateProfiles(self):
        nx = len(self.fileNames) 
        if nx <= 0 :
            return
        
        self.execInitScript()
        
        # calculate common values
        x0 = np.zeros(nx-1)                         # [mm] X0 coordinates of scans
        flag = self.readParameter(0, 'autox0', False)
        printl('', stamp=False)
        printl('Emittance calculation using parameters:')
        printl('Use calculated X0 = %s'%str(flag))
        for i in range(1, nx) :
            if flag:
                x0[i-1] = self.readParameter(i, 'x0', 0.0, float, select='auto')
            else:
                x0[i-1] = self.readParameter(i, 'x0', 0.0, float)
        # parameters
        # R
        R = self.readParameter(0, 'R', 2.0e5, float)    # [Ohm] Faraday cup load resistior
        # l1
        l1 = self.readParameter(0, 'l1', 213.0, float)  # [mm] distance from source to analyzer aperture
        # l2
        l2 = self.readParameter(0, 'l2', 200.0, float)  # [mm] analyzer base
        # d1 and hole area
        d1 = self.readParameter(0, 'd1', 0.4, float)    # [mm] analyzer hole diameter
        a1 = np.pi*d1*d1/4.0                            # [mm**2] analyzer hole area    
        # d2
        d2 = self.readParameter(0, 'd2', 0.5, float)    # [mm] analyzer slit width
        printl('R=%fOhm l1=%fmm l2=%fmm d1=%fmm d2=%fmm'%(R,l1,l2,d1,d2))
        # calculate maximum and integral profiles
        profilemax = np.zeros(nx-1)
        profileint = np.zeros(nx-1)
        for i in range(1, nx) :
            try:
                x,y,index = self.readSignal(i)           # x - [milliRadians] y - [mkA]
                yy = y[index]
                xx = x[index]
                # select unique x values for spline interpolation
                xu, h = np.unique(xx, return_index=True)
                #print(i,h)
                yu = yy[h]
                profilemax[i-1] = -1.0 * np.min(yu)      # [mkA]
                k = 1.0
                if xu[0] < xu[-1]:
                    k = -1.0
                profileint[i-1] = k * trapz(yu, xu) * l2 / d2 /1000.0  # [mkA] 1000.0 from milliradians
                print(i,profileint[i-1])
                # integrate by rectangles method
                profileint[i-1] = k * np.sum(yu[:-1]*np.diff(xu)) * l2 / d2 /1000.0  # [mkA] 1000.0 from milliradians
                print(i,profileint[i-1])
            except:
                self.printExceptionInfo()
        # sort in x0 increasing order
        ix0 = np.argsort(x0)
        #print(ix0)
        x0s = x0[ix0]
        print(x0s)
        profileint = profileint[ix0]
        print(profileint)
        profilemax = profilemax[ix0]
        print(profilemax)
        # remove average x
        xavg = trapz(x0s * profileint, x0s) / trapz(profileint, x0s)
        print('Average X0 %f mm'%xavg)
        x0s = x0s - xavg
        # cross-section current
        Ics = trapz(profileint, x0s)*d1/a1/1000.0
        printl('Cross-section current %f mA'%Ics)
        # calculate total current
        index = np.where(x0s >= 0.0)[0]
        Ir = trapz(x0s[index]*profileint[index], x0s[index])*2.0*np.pi/a1/1000.0
        print('Total current right %f mA'%Ir)
        index = np.where(x0s <= 0.0)[0]
        Il = -1.0*trapz(x0s[index]*profileint[index], x0s[index])*2.0*np.pi/a1/1000.0
        print('Total current left %f mA'%Il)
        I = (Il + Ir)/2.0
        printl('Total current %f mA'%I)
        # save profile data
        folder = self.folderName
        fn = os.path.join(str(folder), 'InegralProfile.txt')
        np.savetxt(fn, np.array([x0,profileint]).T, delimiter='; ' )
        fn = os.path.join(str(folder), 'MaximumProfile.txt')
        np.savetxt(fn, np.array([x0,profilemax]).T, delimiter='; ' )
        # plot profiles
        axes = self.mplWidget.canvas.ax
        # plot integral profile
        if int(self.comboBox.currentIndex()) == 0:
            self.clearPicture()
            axes.set_title('Integral profile')
            axes.set_xlabel('X0, mm')
            axes.set_ylabel('Beamlet current, mkA')
            axes.plot(x0s, profileint, 'd-', label='Integral Profile')
            #axes.plot(x0s, gaussfit(x0s,profileint,x0s), '--', label='Gaussian fit')
            axes.grid(True)
            axes.legend(loc='best') 
            self.mplWidget.canvas.draw()
            #return
        # plot maximal profile
        if int(self.comboBox.currentIndex()) == 1:
            self.clearPicture()
            axes.set_title('Maximum profile')
            axes.set_xlabel('X0, mm')
            axes.set_ylabel('Maximal current, mkA')
            axes.plot(x0s, profilemax, 'o-', label='Maximum Profile')
            #axes.plot(x0s, gaussfit(x0s,profilemax,x0s), '--', label='Gaussian fit')
            axes.grid(True)
            axes.legend(loc='best') 
            self.mplWidget.canvas.draw()

    def calculateEmittance(self):
        def plot(*args, **kwargs):
            axes = self.mplWidget.canvas.ax
            axes.plot(*args, **kwargs)
            #zoplot()
            #xlim = axes.get_xlim()
            #axes.plot(xlim, [0.0,0.0], color='k')
            #axes.set_xlim(xlim)
            axes.grid(True)
            axes.legend(loc='best') 
            self.mplWidget.canvas.draw()

        def draw():
            self.mplWidget.canvas.draw()

        def zoplot(v=0.0, color='k'):
            axes = self.mplWidget.canvas.ax
            xlim = axes.get_xlim()
            axes.plot(xlim, [v, v], color=color)
            axes.set_xlim(xlim)

        def voplot(v=0.0, color='k'):
            axes = self.mplWidget.canvas.ax
            ylim = axes.get_ylim()
            axes.plot([v, v], ylim, color=color)
            axes.set_ylim(ylim)

        def cls():
            self.clearPicture()
            
        if self.data is None :
            return
        nx = len(self.fileNames) 
        if nx <= 0 :
            return
        
        self.execInitScript()
        # calculate common values
        x0 = np.zeros(nx-1)                         # [mm] X0 coordinates of scans
        ndh = np.zeros(nx-1)                        # [mm] displacement of analyzer slit (number n) from axis
        x0c = np.zeros(nx-1)                        # [mm] X0 coordinates of scans
        flag = self.readParameter(0, 'autox0', False)
        printl('', stamp=False)
        printl('Emittance calculation using parameters:')
        printl('Use calculated X0 = %s'%str(flag))
        for i in range(1, nx) :
            if flag:
                x0[i-1] = self.readParameter(i, 'x0', 0.0, float, select='auto')
            else:
                x0[i-1] = self.readParameter(i, 'x0', 0.0, float)
            ndh[i-1] = self.readParameter(i, 'ndh', 0.0, float)
            x0c[i-1] = self.readParameter(i, 'x0', 0.0, float, select='auto')
        # parameters
        # R
        R = self.readParameter(0, 'R', 2.0e5, float)    # [Ohm] Faraday cup load resistior
        # l1
        l1 = self.readParameter(0, 'l1', 213.0, float)  # [mm] distance from source to analyzer aperture
        # l2
        l2 = self.readParameter(0, 'l2', 200.0, float)  # [mm] analyzer base
        # d1 and hole area
        d1 = self.readParameter(0, 'd1', 0.4, float)    # [mm] analyzer hole diameter
        a1 = np.pi*d1*d1/4.0                            # [mm**2] analyzer hole area    
        # d2
        d2 = self.readParameter(0, 'd2', 0.5, float)    # [mm] analyzer slit width
        printl('R=%fOhm l1=%fmm l2=%fmm d1=%fmm d2=%fmm'%(R,l1,l2,d1,d2))
        # calculate maximum and integral profiles
        profilemax = np.zeros(nx-1)
        profileint = np.zeros(nx-1)
        for i in range(1, nx) :
            try:
                x,y,index = self.readSignal(i)           # x - [milliRadians] y - [mkA]
                yy = y[index]
                xx = x[index]
                profilemax[i-1] = -1.0 * np.min(yy)      # [mkA]
                k = 1.0
                if xx[0] < xx[-1]:
                    k = -1.0
                # integrate by trapezoids method
                profileint[i-1] = k * trapz(yy, xx) * l2 / d2 /1000.0  # [mkA] 1000.0 from milliradians
                #print(i,profileint[i-1])
                # integrate by rectangles method
                #profileint[i-1] = k * np.sum(yy[:-1]*np.diff(xx)) * l2 / d2 /1000.0  # [mkA] 1000.0 from milliradians
                #print(i,profileint[i-1])
            except:
                self.printExceptionInfo()
        # sort x0 in increasing order
        ix0 = np.argsort(x0)
        x0s = x0[ix0]
        profileint = profileint[ix0]
        profilemax = profilemax[ix0]
        # remove average x
        xavg = trapz(x0s * profileint, x0s) / trapz(profileint, x0s)
        print('Average X0 %f mm'%xavg)
        x0s = x0s - xavg
        # cross-section current
        Ics = trapz(profileint, x0s)*d1/a1/1000.0
        printl('Cross-section current %f mA'%Ics)
        # calculate total current
        index = np.where(x0s >= 0.0)[0]
        Ir = trapz(x0s[index]*profileint[index], x0s[index])*2.0*np.pi/a1/1000.0
        print('Total current right %f mA'%Ir)
        index = np.where(x0s <= 0.0)[0]
        Il = -1.0*trapz(x0s[index]*profileint[index], x0s[index])*2.0*np.pi/a1/1000.0
        print('Total current left %f mA'%Il)
        I = (Il + Ir)/2.0
        printl('Total current %f mA'%I)
        # save profile data
        folder = self.folderName
        fn = os.path.join(str(folder), 'InegralProfile.txt')
        np.savetxt(fn, np.array([x0,profileint]).T, delimiter='; ' )
        fn = os.path.join(str(folder), 'MaximumProfile.txt')
        np.savetxt(fn, np.array([x0,profilemax]).T, delimiter='; ' )
        # plot profiles
        axes = self.mplWidget.canvas.ax
        # plot integral profile
        if int(self.comboBox.currentIndex()) == 0:
            self.clearPicture()
            axes.set_title('Integral profile')
            axes.set_xlabel('X0, mm')
            axes.set_ylabel('Beamlet current, mkA')
            axes.plot(x0s, profileint, 'd-', label='Integral Profile')
            #axes.plot(x0s, gaussfit(x0s,profileint,x0s), '--', label='Gaussian fit')
            axes.grid(True)
            axes.legend(loc='best') 
            self.mplWidget.canvas.draw()
            return
        # plot maximal profile
        if int(self.comboBox.currentIndex()) == 1:
            self.clearPicture()
            axes.set_title('Maximum profile')
            axes.set_xlabel('X0, mm')
            axes.set_ylabel('Maximal current, mkA')
            axes.plot(x0s, profilemax, 'o-', label='Maximum Profile')
            #axes.plot(x0s, gaussfit(x0s,profilemax,x0s), '--', label='Gaussian fit')
            axes.grid(True)
            axes.legend(loc='best') 
            self.mplWidget.canvas.draw()
            return
        
        # calculate emittance contour plot
        # number of points for emittance matrix
        N = 200
        # calculate nx-1 x N arrays
        # X0 [mm]
        X0 = np.zeros((N,nx-1), dtype=np.float64)
        # X0' [milliRadians]
        Y0 = np.zeros((N,nx-1), dtype=np.float64)
        # current density [?]
        Z0 = np.zeros((N,nx-1), dtype=np.float64)
        # selected subarrays of data points
        v = []
        xsmin = 1e99
        xsmax = -1e99
        for i in range(1, nx) :
            if flag:
                X0[:,i-1] = self.readParameter(i, 'x0', 0.0, float, select='auto') - xavg
            else:
                X0[:,i-1] = self.readParameter(i, 'x0', 0.0, float) - xavg
            x,y,index = self.readSignal(i)           # x in [milliRadians]; y < 0.0 in [mkA]
            # center the plot over X0
            x = x - xavg/l1 * 1000.0
            v.append((x[index], -y[index]))
            xsmin = min([xsmin, x[index].min()])
            xsmax = max([xsmax, x[index].max()])
        # X0' range array
        ys = np.linspace(xsmin, xsmax, N)
        # fill data arrays
        for i in range(nx-1) :
            Y0[:,i] = ys
            x = v[i][0]
            y = v[i][1]
            index = np.unique(x, return_index=True)[1]
            #Z0[:,i] = np.interp(Y0[:,i], v[i][0], v[i][1])
            f = interp1d(x[index], y[index], kind='linear', bounds_error=False, fill_value=0.0)
            #f = interp1d(x, y, kind='linear', bounds_error=False, fill_value=0.0)
            Z0[:,i] = f(Y0[:,i])
        # sort data according rising x0
        X1 = X0.copy()
        Y1 = Y0.copy()
        Z1 = Z0.copy()
        for i in range(nx-1) :
            X1[:,ix0[i]] = X0[:,i]
            Y1[:,ix0[i]] = Y0[:,i]
            Z1[:,ix0[i]] = Z0[:,i]
        # remove negative data
        Z1[Z1 < 0.0] = 0.0
        # debug plot 6
        if int(self.comboBox.currentIndex()) == 6:
            self.clearPicture()
            axes.contour(X1, Y1, Z1)
            axes.grid(True)
            axes.set_title('Interpolated N x (nx-1) and sorted X0 data')
            self.mplWidget.canvas.draw()
            return

        
        # reduce regular divergence
        for i in range(nx-1) :
            x = v[i][0]
            y = v[i][1]
            index = np.unique(x, return_index=True)[1]
            f = interp1d(x[index], y[index], kind='linear', bounds_error=False, fill_value=0.0)
            # using calculated X0
            Z1[:,ix0[i]] = f(Y0[:,ix0[i]] + x0c[i]/l1*1000.0)
            #Z1[:,ix0[i]] = f(Y0[:,ix0[i]] + X0[:,ix0[i]]/l1*1000.0)
        # remove negative data
        Z1[Z1 < 0.0] = 0.0
        # debug plot 7
        if int(self.comboBox.currentIndex()) == 7:
            self.clearPicture()
            axes.contour(X1, Y1, Z1)
            axes.grid(True)
            axes.set_title('Regular divergence reduced N x (nx-1)')
            self.mplWidget.canvas.draw()
            return
        # debug plot 13
        if int(self.comboBox.currentIndex()) == 13:
            cls()
            indexes = self.listWidget.selectedIndexes()
            for j in indexes:
                k = j.row()             
                plot(Y1[:,k-1], Z1[:,k-1], label='-d'+str(k))
                axes.set_title('Shifted elementary jets')
                axes.set_xlabel('X\', milliRadians')
                axes.set_ylabel('Current, mkA')
                self.mplWidget.canvas.draw()
                r = self.readParameter(k-1, 'range', [0,-1])
                m = self.readParameter(k-1, 'minindex', 0)
                v = self.readParameter(k-1, 'minvoltage', 0.0)/R*1.0e6
                s = self.readParameter(k-1, "scale", 1.0, float)
                h = self.readParameter(k-1, "ndh", 0.0, float)
                print('i=%d Xmax=%fmm r=%s'%(m, (h - s*v) / l2 * 1000.0, str(r)))
            return

        
        # calculate NxN array
        X2 = np.zeros((N, N), dtype=np.float64)
        Y2 = np.zeros((N, N), dtype=np.float64)
        Z2 = np.zeros((N, N), dtype=np.float64)
        xs = np.linspace(x0.min(), x0.max(), N)
        # X and Y
        for i in range(N) :
            X2[i,: ] = np.linspace(x0.min(), x0.max(), N)
            Y2[:,i] = ys
        # Z
        for i in range(N) :
            #Z2[i,:] = np.interp(X2[i,:], X0[i,:], Z0[i,:])
            x = X1[i,:]
            y = Z1[i,:]
            index = np.unique(x, return_index=True)[1]
            f = interp1d(x[index], y[index], kind='cubic', bounds_error=False, fill_value=0.0)
            #f = interp1d(X1[i,:], Z1[i,:], kind='linear', bounds_error=False, fill_value=0.0)
            Z2[i,:] = f(X2[i,:])
        # remove negative currents
        Z2[Z2 < 0.0] = 0.0
        Z2t = np.sum(Z2) * (Y2[1,0]-Y2[0,0])/d2*l2/1000.0 * (X2[0,1]-X2[0,0])*d1/a1/1000.0
        print('Total Z2 (cross-section current) = %f mA'%Z2t)
        # debug plot 14
        if int(self.comboBox.currentIndex()) == 14:
            self.clearPicture()
            axes.contour(X2, Y2, Z2)
            axes.grid(True)
            axes.set_title('N x N no divergence')
            self.mplWidget.canvas.draw()
            #return
        X3 = X2
        Y3 = Y2
        Z3 = np.zeros((N, N), dtype=np.float64)
        # return regular divergence back
        for i in range(N) :
            x = Y2[:,i]
            y = Z2[:,i]
            index = np.unique(x, return_index=True)[1]
            f = interp1d(x[index], y[index], kind='cubic', bounds_error=False, fill_value=0.0)
            Z3[:,i] = f(Y3[:,i] - X3[:,i]/l1*1000.0)
        Z3[Z3 < 0.0] = 0.0
        # integrate emittance from cross-section to circular beam
        X = X2
        Y = Y2
        Z = np.zeros((N, N), dtype=np.float64)
        # calculate average X
        Xavg = np.sum(X2*Z2)/np.sum(Z2)
        # Z for whole beam
        s = np.zeros((1, N), dtype=np.float64)
        for i in range(N) :
            s *= 0.0
            x = np.abs(X[0,i] - Xavg)
            for j in range(N):
                ksi = np.abs(X[0,j] - Xavg)
                if ksi > x:
                    s += Z2[:,j]*ksi/np.sqrt(ksi*ksi - x*x)
            Z[:,i] = s
        # convert Z to milliAmperes/cell
        Z *= (Y[1,0]-Y[0,0])/d2*l2/1000.0 * (X[0,1]-X[0,0])**2/a1 / 1000.0
        print('Total Z (beam current) = %f mA'%np.sum(Z))
        # return regular divergence back
        for i in range(N) :
            #Z[:,i] = np.interp(Y[:,i] - X[:,i]/l1*1000.0, Y[:,i], Z[:,i])
            x = Y[:,i]
            y = Z[:,i]
            index = np.unique(x, return_index=True)[1]
            f = interp1d(x[index], y[index], kind='cubic', bounds_error=False, fill_value=0.0)
            #f = interp1d(Y[:,i], Z[:,i], kind='linear', bounds_error=False, fill_value=0.0)
            Z[:,i] = f(Y[:,i] - X[:,i]/l1*1000.0)
        # remove negative currents
        Z[Z < 0.0] = 0.0
        # calculate emittance values
        q=1.6e-19        # [Q] electron charge
        m=1.6726e-27     # [kg]  proton mass
        c=2.9979e8       # [m/s] speed of light
        #U=32.7*1000.0   # [V] beam energy
        U = self.readParameter(0, 'energy', 32000.0, float)
        printl('Beam energy U= %f V'%U)
        beta = np.sqrt(2.0*q*U/m)/c
        # RMS Emittance
        # calculate average X and X'
        zt = np.sum(Z)
        XZ = X*Z
        YZ = Y*Z
        Xavg = np.sum(XZ)/zt
        Yavg = np.sum(YZ)/zt
        # subtract average values 
        X = X - Xavg
        Y = Y - Yavg
        # calculate moments 
        XYavg = np.sum(X*YZ)/zt
        XXavg = np.sum(X*XZ)/zt
        YYavg = np.sum(Y*YZ)/zt
        RMS = np.sqrt(XXavg*YYavg-XYavg*XYavg)
        #XX1avg = np.s((X-Xavg)*(X-Xavg)*Z)/zt
        #YY1avg = np.s((Y-Yavg)*(Y-Yavg)*Z)/zt
        #XY1avg = np.s((X-Xavg)*(Y-Yavg)*Z)/zt
        #RMS1 = np.sqrt(XX1avg*YY1avg-XY1avg*XY1avg)
        print('Xavg=%f mm   X\'avg=%f mRad'%(Xavg, Yavg))
        #print('RMS=%f RMS1=%f'%(RMS*beta, RMS1*beta))
        printl('Normalized RMS Emittance %5.3f Pi*mm*mrad'%(RMS*beta))

        # save data to text file
        fn = os.path.join(str(folder), _progName + '_X.gz')
        np.savetxt(fn, X, delimiter='; ' )
        fn = os.path.join(str(folder), _progName + '_Y.gz')
        np.savetxt(fn, Y, delimiter='; ' )
        fn = os.path.join(str(folder), _progName + '_Z.gz')
        np.savetxt(fn, Z, delimiter='; ' )
        fn = os.path.join(str(folder), _progName + '_X_cs.gz')
        np.savetxt(fn, X3, delimiter='; ' )
        fn = os.path.join(str(folder), _progName + '_Y_cs.gz')
        np.savetxt(fn, Y3, delimiter='; ' )
        fn = os.path.join(str(folder), _progName + '_Z_cs.gz')
        np.savetxt(fn, Z3, delimiter='; ' )

        nz = 100
        zl = np.linspace(0.0, Z.max(), nz)
        zi = np.zeros(nz)
        zn = np.zeros(nz)
        zr = np.zeros(nz)

        for i in range(nz):
            mask = Z >= zl[i]
            #print(len(index))
            zn[i] = np.sum(mask)
            za = Z[mask]
            xa = X[mask]
            ya = Y[mask]
            zt = np.sum(za)
            zi[i] = zt
            xys = np.sum(xa*ya*za)/zt
            xxs = np.sum(xa*xa*za)/zt
            yys = np.sum(ya*ya*za)/zt
            #print(xxs*yys-xys*xys)
            zr[i] = np.sqrt(max([xxs*yys-xys*xys, 0.0]))

        # levels to draw
        #fractions = np.array([0.5,0.7,0.9])    # fraction of the beam current
        fractions = np.array(self.readParameter(0, 'fractions', [0.5,0.7,0.9]))
        levels = fractions*0.0
        emit = fractions*0.0
        rms = fractions*0.0
        zs = np.sum(Z)
        for i in range(len(fractions)):
            index = np.where(zi >= fractions[i]*zs)[0]
            n = index.max()
            levels[i] = zl[n]
            emit[i] = zn[n]
            rms[i] = zr[n]
        
        emit = emit*(X[0,0]-X[0,1])*(Y[0,0]-Y[1,0])/np.pi*beta
        rms = rms*beta
        printl('% Current  Normalized emittance      Normalized RMS emittance')
        for i in range(len(levels)):
            printl('%2.0f %%       %5.3f Pi*mm*milliRadians  %5.3f Pi*mm*milliRadians'%(fractions[i]*100.0, emit[i], rms[i]))
        printl('%2.0f %%                                %5.3f Pi*mm*milliRadians'%(100.0, RMS*beta))
        # plot contours
        if int(self.comboBox.currentIndex()) == 2:
            self.clearPicture()
            axes.contour(X, Y, Z, linewidths=1.0)
            axes.grid(True)
            axes.set_title('Emittance contour plot')
            #axes.set_ylim([xsmin,xsmax])
            axes.set_xlabel('X, mm')
            axes.set_ylabel('X\', milliRadians')
            axes.annotate('Total current %4.1f mA'%I + '; Normalized RMS Emittance %5.3f Pi*mm*mrad'%(RMS*beta),
                          xy=(.5, .2), xycoords='figure fraction',
                          horizontalalignment='center', verticalalignment='top',
                          fontsize=11)
            #axes.annotate(' Normalized RMS Emittance %5.3f Pi*mm*mrad'%(RMS*beta),
            #              xy=(.5, .85), xycoords='figure fraction',
            #              horizontalalignment='center', verticalalignment='top',
            #              fontsize=12)
            self.mplWidget.canvas.draw()
        # plot filled contours
        if int(self.comboBox.currentIndex()) == 3:
            self.clearPicture()
            axes.contourf(X, Y, Z)
            axes.grid(True)
            axes.set_title('Emittance color plot')
            #axes.set_ylim([xsmin,xsmax])
            axes.set_xlabel('X, mm')
            axes.set_ylabel('X\', milliRadians')
            axes.annotate('Total current %4.1f mA'%I + '; Normalized RMS Emittance %5.3f Pi*mm*mrad'%(RMS*beta),
                          xy=(.5, .2), xycoords='figure fraction',
                          horizontalalignment='center', verticalalignment='top',
                          fontsize=11, color='white')
            self.mplWidget.canvas.draw()
        # plot levels
        if int(self.comboBox.currentIndex()) == 4:
            self.clearPicture()
            CS = axes.contour(X, Y, Z, linewidths=1.0, levels=levels[::-1])
            axes.grid(True)
            axes.set_title('Emittance contours for levels')
            #axes.set_ylim([xsmin,xsmax])
            axes.set_xlabel('X, mm')
            axes.set_ylabel('X\', milliRadians')
            labels = ['%2d %% of current'%(fr*100) for fr in np.sort(fractions)[::-1]]
            for i in range(len(labels)):
                CS.collections[i].set_label(labels[i])
            axes.legend(loc='upper left')
            #axes.annotate('some text here',(1.4,1.6))
            axes.annotate('Total current %4.1f mA'%I + '; Normalized RMS Emittance %5.3f Pi*mm*mrad'%(RMS*beta),
                          xy=(.5, .2), xycoords='figure fraction',
                          horizontalalignment='center', verticalalignment='top',
                          fontsize=11)
            self.mplWidget.canvas.draw()
        if int(self.comboBox.currentIndex()) == 15:
            self.clearPicture()
            axes.contour(X3, Y3, Z3, linewidths=1.0)
            axes.grid(True)
            axes.set_title('Emittance of cross-section contour plot')
            axes.set_xlabel('X, mm')
            axes.set_ylabel('X\', milliRadians')
            axes.annotate('Total current %4.1f mA'%I + '; Normalized RMS Emittance %5.3f Pi*mm*mrad'%(RMS*beta),
                          xy=(.5, .2), xycoords='figure fraction',
                          horizontalalignment='center', verticalalignment='top',
                          fontsize=11)
            self.mplWidget.canvas.draw()
        
    def saveSettings(self, folder='', fileName=_settingsFile, local=False) :
        fullName = os.path.join(str(folder), fileName)
        dbase = shelve.open(fullName, flag='n')
        # data folder
        dbase['folder'] = self.folderName
        # default smooth
        dbase['smooth'] = int(self.spinBox.value())
        # scan voltage channel number
        dbase['scan'] = int(self.spinBox_2.value())
        # result combo
        dbase['result'] = int(self.comboBox.currentIndex())
        comboitems = [self.comboBox_2.itemText(count) for count in range(self.comboBox_2.count())]
        if len(comboitems) > 10 :
            comboitems = comboitems[:10]
        dbase['history'] = comboitems
        # save paramsAuto
        dbase['paramsAuto'] = self.paramsAuto
        dbase.close()
        print('Configuration saved to %s'%fullName)
        return True
   
    def restoreSettings(self, folder='', fileName=_settingsFile, local=False) :
        # execute init script
        self.execInitScript(folder)
        # read saved settings
        try :
            fullName = os.path.join(str(folder), fileName)
            dbase = shelve.open(fullName)
            # global settings
            if not local :
                # data folder
                self.folderName = dbase['folder']
                # history
                self.comboBox_2.currentIndexChanged.disconnect(self.selectionChanged)
                self.comboBox_2.clear()
                self.comboBox_2.addItems(dbase['history'])
                self.comboBox_2.currentIndexChanged.connect(self.selectionChanged)
            # smooth
            self.spinBox.setValue(dbase['smooth'])
            # result comboBox
            self.comboBox.setCurrentIndex(dbase['result'])
            # scan voltage channel number
            self.spinBox_2.setValue(dbase['scan'])
            # restore paramsAuto
            self.paramsAuto = dbase['paramsAuto']
            print('Configuration restored from %s.'%fullName)
            return True
        except :
            self.printExceptionInfo()
            print('Configuration file %s restore error.'%fullName)
        finally:
            dbase.close()
        return False

    def execInitScript(self, folder=None, fileName=_initScript):
        if folder is None :
            folder = self.folderName
        try:
            fullName = os.path.join(str(folder), fileName)
            exec(open(fullName).read(), globals(), locals())
            print('Init script %s executed'%fullName)
        except:
            self.printExceptionInfo()
            print('Init script %s error.'%fullName)

    def printExceptionInfo(self):
        (tp, value) = sys.exc_info()[:2]
        print('Exception %s %s'%(str(tp), str(value)))

if __name__ == '__main__':
    # create the GUI application
    app = QApplication(sys.argv)
    # instantiate the main window
    dmw = DesignerMainWindow()
    app.aboutToQuit.connect(dmw.onQuit)
    # show it
    dmw.show()
    # start the Qt main loop execution, exiting from this script
    # with the same return code of Qt application
    sys.exit(app.exec_())